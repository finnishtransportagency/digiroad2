package fi.liikennevirasto.digiroad2.util.assetUpdater

import fi.liikennevirasto.digiroad2.asset.TrafficDirection.toSideCode
import fi.liikennevirasto.digiroad2.asset._
import fi.liikennevirasto.digiroad2.client.{RoadLinkChange, RoadLinkInfo}
import fi.liikennevirasto.digiroad2.linearasset.LinearAssetFiller._
import fi.liikennevirasto.digiroad2.linearasset._
import fi.liikennevirasto.digiroad2.service.linearasset.{LinearAssetTypes, Measures, RoadWidthService}
import fi.liikennevirasto.digiroad2.util.{LinearAssetUtils, LogUtils, Parallel}
import org.joda.time.DateTime

sealed case class RoadWidthMap(linkId: String, adminClass: AdministrativeClass, mTKClassWidth: MTKClassWidth, linkLength: Double, trafficDirection: TrafficDirection)

class RoadWidthUpdater(service: RoadWidthService) extends DynamicLinearAssetUpdater(service) {
  
  override def operationForNewLink(change: RoadLinkChange, onlyNeededNewRoadLinks: Seq[RoadLink], changeSets: ChangeSet): Option[OperationStep] = {
    val newLinkInfo = change.newLinks.head
    val roadWidth = MTKClassWidth(newLinkInfo.roadClass)
    val roadLink = onlyNeededNewRoadLinks.find(_.linkId == newLinkInfo.linkId)
    if (newLinkInfo.adminClass != State && roadWidth.value != MTKClassWidth.Unknown.value && roadLink.nonEmpty){
      val newAsset = PersistedLinearAsset(0, newLinkInfo.linkId, sideCode = toSideCode(roadLink.get.trafficDirection).value,
        value = Some(createValue(roadWidth)),
        startMeasure = 0, endMeasure = newLinkInfo.linkLength, createdBy = Some(AutoGeneratedUsername.mtkClassDefault),
        createdDateTime = Some(DateTime.now()),
        modifiedBy = None, modifiedDateTime = None, expired = false, typeId = LinearAssetTypes.RoadWidthAssetTypeId,
        timeStamp = LinearAssetUtils.createTimeStamp(), geomModifiedDate = Some(DateTime.now()),
        linkSource = LinkGeomSource.NormalLinkInterface, 
        verifiedBy = service.getVerifiedBy(AutoGeneratedUsername.mtkClassDefault, LinearAssetTypes.RoadWidthAssetTypeId), 
        verifiedDate = None,
        informationSource = Some(MmlNls))
      Some(OperationStep(Seq(newAsset), Some(changeSets),Seq()))
    }else {
      None
    }
  }

  override def additionalOperations(operationStep: OperationStep, changes: Seq[RoadLinkChange]): Option[OperationStep] ={
    adjustWidthsByRoadClass(operationStep,changes)
  }

  def adjustValue(newLinksWithAssetsGroup: Map[RoadLinkInfo, Seq[PersistedLinearAsset]]): Seq[Some[OperationStep]] = {
    newLinksWithAssetsGroup.flatMap(newLinkWithAssets => {
      val (newLink, assets) = newLinkWithAssets
      assets.map(asset => {
        if (asset.id != 0) {
          if (widthNeedUpdating(asset, newLink)) {
            val modifiedAsset = PersistedLinearAsset(asset.id, newLink.linkId,
              sideCode = toSideCode(newLink.trafficDirection).value,
              value = Some(extractAndUpdate(asset, newLink)),
              startMeasure = asset.startMeasure, endMeasure = asset.endMeasure,
              createdBy = asset.createdBy,
              createdDateTime = asset.createdDateTime,
              modifiedBy = Some(AutoGeneratedUsername.mtkClassDefault), Some(DateTime.now()),
              expired = false, typeId = LinearAssetTypes.RoadWidthAssetTypeId,
              timeStamp = LinearAssetUtils.createTimeStamp(), geomModifiedDate = Some(DateTime.now()),
              linkSource = LinkGeomSource.NormalLinkInterface,
              verifiedBy = service.getVerifiedBy(AutoGeneratedUsername.mtkClassDefault, LinearAssetTypes.RoadWidthAssetTypeId), verifiedDate = None,
              informationSource = Some(MmlNls), oldId = asset.id
            )
            val changeSetForOperationStep = ChangeSet(droppedAssetIds = Set.empty[Long],
              expiredAssetIds = Set.empty[Long],
              adjustedMValues = Seq.empty[MValueAdjustment],
              adjustedSideCodes = Seq.empty[SideCodeAdjustment],
              valueAdjustments = Seq(ValueAdjustment(modifiedAsset.id, modifiedAsset.typeId, modifiedAsset.value.get, modifiedAsset.modifiedBy.get)))
             Some(OperationStep(assetsAfter = Seq(modifiedAsset), changeInfo = Some(changeSetForOperationStep), assetsBefore = Seq()))
          } else Some(OperationStep(assetsAfter = Seq(asset), changeInfo = None, assetsBefore = Seq()))
        } else handleGeneratedPart(asset, newLink)
      })
    }).toSeq
  }

  private def adjustWidthsByRoadClass(operationStep: OperationStep,changes: Seq[RoadLinkChange]) = {

    def parallelLoop(filteredNewLinksWithAssetsAfter: Map[RoadLinkInfo, Seq[PersistedLinearAsset]]) = {
      val newLinksWithAssetsGroups = filteredNewLinksWithAssetsAfter.grouped(groupSizeForParallelRun).toList.par
      val totalTasks = newLinksWithAssetsGroups.size
      val level = if (totalTasks < maximumParallelismLevel) totalTasks else maximumParallelismLevel
      logger.info(s"Asset groups: $totalTasks, parallelism level used: $level")

      new Parallel().operation(newLinksWithAssetsGroups, level) { tasks =>
        tasks.flatMap(newLinksWithAssetsGroup => {
          LogUtils.time(logger, s"Adjusting road width values on ${newLinksWithAssetsGroup.size} links in a single thread") {
            adjustValue(newLinksWithAssetsGroup)
          }
        })
      }.toList
    }

    val changeSet: ChangeSet = operationStep.changeInfo.get
    val changesNewLinks = changes.flatMap(_.newLinks)
    val filteredNewLinks = changesNewLinks.filter(newLink => newLink.adminClass != State && MTKClassWidth(newLink.roadClass).value != MTKClassWidth.Unknown.value)
    val filteredLinkIds = filteredNewLinks.map(_.linkId)

    val (assetsToAdjust, otherAssets) = LogUtils.time(logger, s"Partition ${operationStep.assetsAfter.size} road widths", startLogging = true) {
      operationStep.assetsAfter.partition(asset => {
        val validLinkToAdjust = filteredLinkIds.contains(asset.linkId)
        selectOnlyMachineCreated(asset) && validLinkToAdjust
      })
    }

    val filteredNewLinksWithAssetsAfter = assetsToAdjust.groupBy(_.linkId).map(assetsByLinkId => {
      val (linkId, assets) = assetsByLinkId
      val newLink = filteredNewLinks.find(_.linkId == linkId).get
      (newLink, assets)
    })

    if (filteredNewLinksWithAssetsAfter.nonEmpty) {
      val systemEditedUpdated = filteredNewLinksWithAssetsAfter.size match {
        case a if a >= parallelizationThreshold => parallelLoop(filteredNewLinksWithAssetsAfter)
        case _ => adjustValue(filteredNewLinksWithAssetsAfter)
      }

      val originalChangeSetForMerge = Some(OperationStep(changeInfo = Some(changeSet)))
      val (after, changeInfoM) = LogUtils.time(logger, "Merge operation steps after road width value adjust", startLogging = true) {
        mergeAfterAndChangeSets(systemEditedUpdated ++ Seq(originalChangeSetForMerge))
      }
      
      Some(operationStep.copy(
        assetsAfter = after ++ otherAssets,
        changeInfo = changeInfoM
      ))
    } else Some(operationStep)
  }

  private def createValue(replace:MTKClassWidth) = {
    val newWidth = Seq(DynamicProperty("width", "integer", required = true, List(DynamicPropertyValue(replace.width.toString))))
    DynamicValue(value = DynamicAssetValue(newWidth))
  }

  private def handleGeneratedPart(asset: PersistedLinearAsset, newLink: RoadLinkInfo): Some[OperationStep] = {
    val operationUpdated = Some(OperationStep(assetsAfter = Seq(asset.copy(value = Some(extractAndUpdate(asset, newLink)))), changeInfo = None, assetsBefore = Seq()))
    if (widthNeedUpdating(asset, newLink)) operationUpdated else  Some(OperationStep(assetsAfter = Seq(asset), changeInfo = None, assetsBefore = Seq()))
  }
  private def extractAndUpdate(asset: PersistedLinearAsset, newLink: RoadLinkInfo): DynamicValue = {
    val (_, other) = asset.value.get.asInstanceOf[DynamicValue].value.properties.partition(_.publicId == "width")
    val newWidth = Seq(DynamicProperty("width", "integer", required = true, List(DynamicPropertyValue(MTKClassWidth(newLink.roadClass).width.toString))))
    DynamicValue(value = DynamicAssetValue(other ++ newWidth))
  }
  private def widthNeedUpdating(asset: PersistedLinearAsset, newLink: RoadLinkInfo) = {
    extractPropertyValue("width", asset.value.get.asInstanceOf[DynamicValue].value.properties).head != MTKClassWidth(newLink.roadClass).width.toString
  }
  private def extractPropertyValue(key: String, properties: Seq[DynamicProperty]) = {
    properties.filter { property => property.publicId == key }.flatMap { property =>
      property.values.map { value =>
        value.value.toString
      }
    }
  }

  private def selectOnlyMachineCreated(asset: PersistedLinearAsset) = {
    val noEdit = asset.modifiedBy.getOrElse(asset.createdBy.getOrElse("")) == AutoGeneratedUsername.mtkClassDefault
    val partOfConversion = asset.modifiedBy.getOrElse(asset.createdBy.getOrElse("")) == AutoGeneratedUsername.dr1Conversion
    val changesOnlyUnderSamuutus = asset.modifiedBy.getOrElse("") == AutoGeneratedUsername.generatedInUpdate && asset.createdBy.getOrElse("") == AutoGeneratedUsername.mtkClassDefault
    noEdit || partOfConversion || changesOnlyUnderSamuutus
  }
  protected override def persistProjectedLinearAssets(newLinearAssets: Seq[PersistedLinearAsset], onlyNeededNewRoadLinks: Seq[RoadLink]): Unit = {
    newLinearAssets.foreach { linearAsset =>
      val roadLink = onlyNeededNewRoadLinks.find(_.linkId == linearAsset.linkId)
      val id = (linearAsset.createdBy, linearAsset.createdDateTime) match {
        case (Some(createdBy), Some(createdDateTime)) =>
          dao.createLinearAsset(linearAsset.typeId, linearAsset.linkId, linearAsset.expired, linearAsset.sideCode,
            Measures(linearAsset.startMeasure, linearAsset.endMeasure).roundMeasures(), linearAsset.modifiedBy.getOrElse(AutoGeneratedUsername.generatedInUpdate), linearAsset.timeStamp,
            service.getLinkSource(roadLink), fromUpdate = true, Some(createdBy), Some(createdDateTime), linearAsset.modifiedBy, linearAsset.modifiedDateTime, linearAsset.verifiedBy, linearAsset.verifiedDate, Some(MmlNls.value), geometry = service.getGeometry(roadLink))
        case _ =>
          dao.createLinearAsset(linearAsset.typeId, linearAsset.linkId, linearAsset.expired, linearAsset.sideCode,
            Measures(linearAsset.startMeasure, linearAsset.endMeasure).roundMeasures(), linearAsset.createdBy.getOrElse(AutoGeneratedUsername.generatedInUpdate), linearAsset.timeStamp,
            service.getLinkSource(roadLink), verifiedBy = linearAsset.verifiedBy, informationSource = Some(MmlNls.value), geometry = service.getGeometry(roadLink))
      }
      linearAsset.value match {
        case Some(DynamicValue(multiTypeProps)) =>
          val props = setDefaultAndFilterProperties(multiTypeProps, roadLink, linearAsset.typeId)
          service.validateRequiredProperties(linearAsset.typeId, props)
          dynamicLinearAssetDao.updateAssetProperties(id, props, linearAsset.typeId)

        case Some(NumericValue(intValue)) =>
          val multiTypeProps = DynamicAssetValue(Seq(DynamicProperty("width", "integer", true, Seq(DynamicPropertyValue(intValue)))))
          val props = setDefaultAndFilterProperties(multiTypeProps, roadLink, linearAsset.typeId)
          service.validateRequiredProperties(linearAsset.typeId, props)
          dynamicLinearAssetDao.updateAssetProperties(id, props, linearAsset.typeId)

        case _ => logger.error(s"Updating asset's ${linearAsset.id} properties failed")
      }
    }
    if (newLinearAssets.nonEmpty)
      logger.debug(s"Added assets for linkids ${newLinearAssets.map(_.linkId)}")
  }

}

