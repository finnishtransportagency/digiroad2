package fi.liikennevirasto.digiroad2.util.assetUpdater

import fi.liikennevirasto.digiroad2.asset.AutoGeneratedUsername
import fi.liikennevirasto.digiroad2.client.{RoadLinkChange, RoadLinkChangeType}
import fi.liikennevirasto.digiroad2.linearasset.LinearAssetFiller.SideCodeAdjustment
import fi.liikennevirasto.digiroad2.linearasset.{DynamicValue, PersistedLinearAsset, RoadLink}
import fi.liikennevirasto.digiroad2.service.linearasset.{MaintenanceService, Measures, NewLinearAssetMassOperation}
import fi.liikennevirasto.digiroad2.util.{LinearAssetUtils, LogUtils}

class MaintenanceRoadUpdater(service: MaintenanceService) extends DynamicLinearAssetUpdater(service) {

  override def filterChanges(typeId: Int, changes: Seq[RoadLinkChange]): Seq[RoadLinkChange] = {
    LogUtils.time(logger, s"TEST LOG MaintenanceRoadUpdater filterChanges with ${changes.size} changes", startLogging = true) {
      val (remove, other) = super.filterChanges(typeId, changes).partition(_.changeType == RoadLinkChangeType.Remove)
      val linksOther = other.flatMap(_.newLinks.map(_.linkId)).toSet
      val filterChanges = if (linksOther.nonEmpty) {
        if (linksOther.contains("e6724c48-99ff-49d6-8efb-5f12068d8415:1")) {logger.info(s"New RoadLink e6724c48-99ff-49d6-8efb-5f12068d8415:1 present in filterChanges.linksOther")} // REMOVED AFTER BUG SOURCE FOUND
        val links = roadLinkService.getExistingAndExpiredRoadLinksByLinkIds(linksOther, false)
        val filteredLinks = links.filter(_.functionalClass > 4).map(_.linkId)
        val DEBUGLINK = links.find(_.linkId == "e6724c48-99ff-49d6-8efb-5f12068d8415:1") // REMOVE AFTER BUG SOURCE FOUND
        if (DEBUGLINK.nonEmpty && !filteredLinks.contains(DEBUGLINK.get.linkId)) {
          logger.info(s"New RoadLink 'e6724c48-99ff-49d6-8efb-5f12068d8415:1' filtered out of processed links. FunctionalClass is ${DEBUGLINK.get.functionalClass}") // REMOVED AFTER BUG SOURCE FOUND
        }
        else if (DEBUGLINK.isEmpty) {
          logger.info(s"New RoadLink 'e6724c48-99ff-49d6-8efb-5f12068d8415:1' not found by getExistingAndExpiredRoadLinksByLinkIds") // REMOVE AFTER BUG SOURCE FOUND
        }
        other.filter(p => filteredLinks.contains(p.newLinks.head.linkId))
      } else Seq()
      filterChanges ++ remove
    }
  }
  protected override def persistProjectedLinearAssets(newMaintenanceAssets: Seq[PersistedLinearAsset], onlyNeededNewRoadLinks: Seq[RoadLink]): Unit = {
    val DEBUGASSET = newMaintenanceAssets.find(_.linkId == "e6724c48-99ff-49d6-8efb-5f12068d8415:1") // REMOVE AFTER BUG SOURCE FOUND
    if (DEBUGASSET.isEmpty) {logger.info(s"No new maintenanceRoad projected to link e6724c48-99ff-49d6-8efb-5f12068d8415:1")} // REMOVE AFTER BUG SOURCE FOUND
    else {logger.info(s"new MaintenanceRoad with id ${DEBUGASSET.get.id} projected to link e6724c48-99ff-49d6-8efb-5f12068d8415:1")} // REMOVE AFTER BUG SOURCE FOUND
    newMaintenanceAssets.foreach { linearAsset =>
      val roadLink = onlyNeededNewRoadLinks.find(_.linkId == linearAsset.linkId)
      val area = service.getAssetArea(onlyNeededNewRoadLinks.find(_.linkId == linearAsset.linkId), Measures(linearAsset.startMeasure, linearAsset.endMeasure))

      val id =
        (linearAsset.createdBy, linearAsset.createdDateTime) match {
          case (Some(createdBy), Some(createdDateTime)) =>
            service.maintenanceDAO.createLinearAsset(linearAsset.typeId, linearAsset.linkId, linearAsset.expired, linearAsset.sideCode,
              Measures(linearAsset.startMeasure, linearAsset.endMeasure).roundMeasures(), AutoGeneratedUsername.generatedInUpdate, linearAsset.timeStamp,
              service.getLinkSource(roadLink), fromUpdate = true, Some(createdBy), Some(createdDateTime), linearAsset.modifiedBy, linearAsset.modifiedDateTime, area = area)
          case _ =>
            service.maintenanceDAO.createLinearAsset(linearAsset.typeId, linearAsset.linkId, linearAsset.expired, linearAsset.sideCode,
              Measures(linearAsset.startMeasure, linearAsset.endMeasure).roundMeasures(), AutoGeneratedUsername.generatedInUpdate, linearAsset.timeStamp,
              service.getLinkSource(roadLink), area = area)
        }
      linearAsset.value match {
        case Some(DynamicValue(multiTypeProps)) =>
          val props = setDefaultAndFilterProperties(multiTypeProps, roadLink, linearAsset.typeId)
          service.validateRequiredProperties(linearAsset.typeId, props)
          dynamicLinearAssetDao.updateAssetProperties(id, props, linearAsset.typeId)
        case _ => None
      }
    }
    if (newMaintenanceAssets.nonEmpty)
      logger.debug(s"Added assets for linkids ${newMaintenanceAssets.map(_.linkId)}")
  }

}