package fi.liikennevirasto.digiroad2.util.assetUpdater

import fi.liikennevirasto.digiroad2.asset.AutoGeneratedUsername
import fi.liikennevirasto.digiroad2.client.{RoadLinkChange, RoadLinkChangeType}
import fi.liikennevirasto.digiroad2.linearasset.LinearAssetFiller.SideCodeAdjustment
import fi.liikennevirasto.digiroad2.linearasset.{DynamicValue, PersistedLinearAsset, RoadLink}
import fi.liikennevirasto.digiroad2.service.linearasset.{MaintenanceService, Measures, NewLinearAssetMassOperation}
import fi.liikennevirasto.digiroad2.util.{LinearAssetUtils, LogUtils}

class MaintenanceRoadUpdater(service: MaintenanceService) extends DynamicLinearAssetUpdater(service) {

  protected override def persistProjectedLinearAssets(newMaintenanceAssets: Seq[PersistedLinearAsset], onlyNeededNewRoadLinks: Seq[RoadLink]): Unit = {
    newMaintenanceAssets.foreach { linearAsset =>
      val roadLink = onlyNeededNewRoadLinks.find(_.linkId == linearAsset.linkId)
      val area = service.getAssetArea(onlyNeededNewRoadLinks.find(_.linkId == linearAsset.linkId), Measures(linearAsset.startMeasure, linearAsset.endMeasure))

      val id =
        (linearAsset.createdBy, linearAsset.createdDateTime) match {
          case (Some(createdBy), Some(createdDateTime)) =>
            service.maintenanceDAO.createLinearAsset(linearAsset.typeId, linearAsset.linkId, linearAsset.expired, linearAsset.sideCode,
              Measures(linearAsset.startMeasure, linearAsset.endMeasure).roundMeasures(), AutoGeneratedUsername.generatedInUpdate, linearAsset.timeStamp,
              service.getLinkSource(roadLink), fromUpdate = true, Some(createdBy), Some(createdDateTime), linearAsset.modifiedBy, linearAsset.modifiedDateTime, area = area)
          case _ =>
            service.maintenanceDAO.createLinearAsset(linearAsset.typeId, linearAsset.linkId, linearAsset.expired, linearAsset.sideCode,
              Measures(linearAsset.startMeasure, linearAsset.endMeasure).roundMeasures(), AutoGeneratedUsername.generatedInUpdate, linearAsset.timeStamp,
              service.getLinkSource(roadLink), area = area)
        }
      linearAsset.value match {
        case Some(DynamicValue(multiTypeProps)) =>
          val props = setDefaultAndFilterProperties(multiTypeProps, roadLink, linearAsset.typeId)
          service.validateRequiredProperties(linearAsset.typeId, props)
          dynamicLinearAssetDao.updateAssetProperties(id, props, linearAsset.typeId)
        case _ => None
      }
    }
    if (newMaintenanceAssets.nonEmpty)
      logger.debug(s"Added assets for linkids ${newMaintenanceAssets.map(_.linkId)}")
  }

  override def additionalOperations(operationStep: OperationStep, changes: Seq[RoadLinkChange], newRoadLinks: Seq[RoadLink]): Option[OperationStep] = {
    expireMaintenanceRoadsOnInvalidLinks(operationStep, newRoadLinks)
  }

  /***
   * Expires MaintenanceRoad assets that are projected on invalid links
   * Does not remove expired from assetsAfter, as that is done later during adjustment process
   * @param operationStep
   * @param newRoadLinks
   * @return
   */
  private def expireMaintenanceRoadsOnInvalidLinks(operationStep: OperationStep, newRoadLinks: Seq[RoadLink]) = {
    val validRoadLinkIds = newRoadLinks.filter(roadLink => roadLink.functionalClass > 4).map(_.linkId).toSet
    val expiredAssetIds = operationStep.assetsAfter.filterNot(asset => validRoadLinkIds.contains(asset.linkId)).map(_.id).toSet
    val combinedExpiredIds = operationStep.changeInfo.get.expiredAssetIds ++ expiredAssetIds
    val updatedChangeInfo = operationStep.changeInfo.get.copy(expiredAssetIds = combinedExpiredIds)
    Some(OperationStep(
      assetsAfter = operationStep.assetsAfter,
      changeInfo = Some(updatedChangeInfo),
      assetsBefore = operationStep.assetsBefore
      )
    )
  }

}