package fi.liikennevirasto.digiroad2.util.assetUpdater

import fi.liikennevirasto.digiroad2.asset.AutoGeneratedUsername
import fi.liikennevirasto.digiroad2.client.{RoadLinkChange, RoadLinkChangeType}
import fi.liikennevirasto.digiroad2.linearasset.LinearAssetFiller.SideCodeAdjustment
import fi.liikennevirasto.digiroad2.linearasset.{DynamicValue, PersistedLinearAsset, RoadLink}
import fi.liikennevirasto.digiroad2.service.linearasset.{MaintenanceService, Measures, NewLinearAssetMassOperation}
import fi.liikennevirasto.digiroad2.util.LinearAssetUtils

class MaintenanceRoadUpdater(service: MaintenanceService) extends DynamicLinearAssetUpdater(service) {

  override def filterChanges(changes: Seq[RoadLinkChange]): Seq[RoadLinkChange] = {
    val (remove, other) = changes.partition(_.changeType == RoadLinkChangeType.Remove)
    val linksOther = other.flatMap(_.newLinks.map(_.linkId)).toSet
    val filterChanges = if (linksOther.nonEmpty) {
      val links = roadLinkService.getExistingAndExpiredRoadLinksByLinkIds(linksOther,false)
      val filteredLinks = links.filter(_.functionalClass > 4).map(_.linkId)
      other.filter(p => filteredLinks.contains(p.newLinks.head.linkId))
    } else Seq()
    filterChanges ++ remove
  }
  protected override def persistProjectedLinearAssets(newMaintenanceAssets: Seq[PersistedLinearAsset], roadLinks: Seq[RoadLink]): Unit = {
    val (toInsert, toUpdate) = newMaintenanceAssets.partition(_.id == 0L)
  
   if (toUpdate.nonEmpty) {
      val persisted = dynamicLinearAssetDao.fetchDynamicLinearAssetsByIds(toUpdate.map(_.id).toSet).groupBy(_.id)
      updateProjected(toUpdate, persisted)
      if (newMaintenanceAssets.nonEmpty)
        logger.debug(s"Updated ids/linkids ${toUpdate.map(a => (a.id, a.linkId))}")
    }
    toInsert.foreach { linearAsset =>
      val roadLink = roadLinks.find(_.linkId == linearAsset.linkId)
      val area = service.getAssetArea(roadLinks.find(_.linkId == linearAsset.linkId), Measures(linearAsset.startMeasure, linearAsset.endMeasure))

      val id =
        (linearAsset.createdBy, linearAsset.createdDateTime) match {
          case (Some(createdBy), Some(createdDateTime)) =>
            service.maintenanceDAO.createLinearAsset(linearAsset.typeId, linearAsset.linkId, linearAsset.expired, linearAsset.sideCode,
              Measures(linearAsset.startMeasure, linearAsset.endMeasure).roundMeasures(), AutoGeneratedUsername.generatedInUpdate, linearAsset.timeStamp,
              service.getLinkSource(roadLink), fromUpdate = true, Some(createdBy), Some(createdDateTime), linearAsset.modifiedBy, linearAsset.modifiedDateTime, area = area)
          case _ =>
            service.maintenanceDAO.createLinearAsset(linearAsset.typeId, linearAsset.linkId, linearAsset.expired, linearAsset.sideCode,
              Measures(linearAsset.startMeasure, linearAsset.endMeasure).roundMeasures(), AutoGeneratedUsername.generatedInUpdate, linearAsset.timeStamp,
              service.getLinkSource(roadLink), area = area)
        }
      linearAsset.value match {
        case Some(DynamicValue(multiTypeProps)) =>
          val props = setDefaultAndFilterProperties(multiTypeProps, roadLink, linearAsset.typeId)
          service.validateRequiredProperties(linearAsset.typeId, props)
          dynamicLinearAssetDao.updateAssetProperties(id, props, linearAsset.typeId)
        case _ => None
      }
    }
    if (newMaintenanceAssets.nonEmpty)
      logger.debug(s"Added assets for linkids ${toInsert.map(_.linkId)}")
  }
  override protected def adjustedSideCode(adjustment: SideCodeAdjustment, oldAssets: Seq[PersistedLinearAsset], roadLinks: Seq[RoadLink], adjustedSideCodes: Seq[SideCodeAdjustment] = Seq()): Unit = {
    service.expireAssets(oldAssets.map(_.id), expired = true,AutoGeneratedUsername.generatedInUpdate, newTransaction = false)
    val adjusted = adjustedSideCodes.map(_.assetId)
    val assets = oldAssets.filter(a => adjusted.contains(a.id)).map(a => {
      val oldAssetValue = a.value.getOrElse(throw new IllegalStateException(s"Value of the old asset ${a.id} of type ${a.typeId} is not available"))
      val roadLink = roadLinks.find(_.linkId == a.linkId).getOrElse(throw new IllegalStateException(s"Road link ${a.linkId} no longer available"))
      NewLinearAssetMassOperation(
        a.typeId, a.linkId, oldAssetValue, adjustedSideCodes.find(_.assetId == a.id).get.sideCode.value,
        Measures(a.startMeasure, a.endMeasure).roundMeasures(), AutoGeneratedUsername.generatedInUpdate, LinearAssetUtils.createTimeStamp(),
        Some(roadLink), true, a.createdBy, a.createdDateTime, a.modifiedBy, a.modifiedDateTime, a.verifiedBy, a.verifiedDate, a.informationSource.map(_.value),
        linkSource = service.getLinkSource(Some(roadLink)),
        geometry = service.getGeometry(Some(roadLink)), expired = false
      )
    })

    assets.map(oldAsset => service.createWithoutTransaction(oldAsset.typeId, oldAsset.linkId, oldAsset.value, adjustment.sideCode.value,
      oldAsset.measures, AutoGeneratedUsername.generatedInUpdate, LinearAssetUtils.createTimeStamp(),
      oldAsset.roadLink, true, oldAsset.createdByFromUpdate, oldAsset.createdDateTimeFromUpdate, oldAsset.modifiedByFromUpdate, oldAsset.modifiedDateTimeFromUpdate, oldAsset.verifiedBy, oldAsset.informationSource
    ))
  }
  
}