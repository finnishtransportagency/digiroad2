package fi.liikennevirasto.digiroad2.util.assetUpdater

import fi.liikennevirasto.digiroad2.asset._
import fi.liikennevirasto.digiroad2.client.{FeatureClass, RoadLinkChange, RoadLinkChangeType}
import fi.liikennevirasto.digiroad2.dao.RoadLinkOverrideDAO.TrafficDirectionDao
import fi.liikennevirasto.digiroad2.dao.linearasset.PostGISSpeedLimitDao
import fi.liikennevirasto.digiroad2.linearasset.LinearAssetFiller._
import fi.liikennevirasto.digiroad2.linearasset._
import fi.liikennevirasto.digiroad2.service.linearasset.{Measures, NewSpeedLimitMassOperation, SpeedLimitService}
import fi.liikennevirasto.digiroad2.util.{KgvUtil, LogUtils}

class SpeedLimitUpdater(service: SpeedLimitService) extends DynamicLinearAssetUpdater(service) {

  val speedLimitDao = new PostGISSpeedLimitDao(roadLinkService)

  override def assetFiller: AssetFiller = SpeedLimitFiller
  
  override def operationForNewLink(change: RoadLinkChange, assetsAll: Seq[PersistedLinearAsset], newRoadLinks: Seq[RoadLink], changeSets: ChangeSet): Option[OperationStep] = {
    val newLinkInfo = change.newLinks.head
    val filteredLinks = newRoadLinks.filterNot(link => Seq(HardShoulder, CycleOrPedestrianPath, TractorRoad).contains(link.linkType))
    val roadLinkFound = filteredLinks.exists(_.linkId == newLinkInfo.linkId)
    if(roadLinkFound) {
      service.persistUnknown(Seq(UnknownSpeedLimit(newLinkInfo.linkId, newLinkInfo.municipality.get, newLinkInfo.adminClass)),newTransaction = false)
      None
    } else None
  }

  override def additionalRemoveOperationMass(expiredLinks:Seq[String]): Unit = {
    service.purgeUnknown(Set(),expiredLinks,newTransaction = false)
  }

  override def nonAssetUpdate(change: RoadLinkChange, assetsAll: Seq[PersistedLinearAsset], changeSets: ChangeSet): Option[OperationStep] = {
    change.changeType match {
      case RoadLinkChangeType.Replace | RoadLinkChangeType.Split => {
        val oldLinkIds = change.oldLink.get.linkId
        val trafficDirectionChanged = isRealTrafficDirectionChange(change)
        val oldUnknownLSpeedLimit = service.getUnknownByLinkIds(Set(oldLinkIds),newTransaction = false)
        if (oldUnknownLSpeedLimit.nonEmpty || trafficDirectionChanged) {
          service.purgeUnknown(Set(),oldUnknownLSpeedLimit.map(_.linkId),newTransaction = false) // recreate unknown speedlimit
          service.persistUnknown(change.newLinks.map(l=>UnknownSpeedLimit(l.linkId, l.municipality.get, l.adminClass)),newTransaction = false)
        }
        None
      }
      case _ => None
    }
  }
  
  def isRealTrafficDirectionChange(change: RoadLinkChange): Boolean = {
    change.newLinks.exists(newLink => {
      val oldOriginalTrafficDirection = change.oldLink.get.trafficDirection
      val newOriginalTrafficDirection = newLink.trafficDirection
      val replaceInfo = change.replaceInfo.find(_.newLinkId.getOrElse("") == newLink.linkId).get
      val isDigitizationChange = replaceInfo.digitizationChange
      val overWrittenTdValueOnNewLink = TrafficDirectionDao.getExistingValue(newLink.linkId)

      if (overWrittenTdValueOnNewLink.nonEmpty) false
      else {
        if (isDigitizationChange) oldOriginalTrafficDirection != TrafficDirection.switch(newOriginalTrafficDirection)
        else oldOriginalTrafficDirection != newOriginalTrafficDirection
      }
    })
  }
  
  override def adjustLinearAssets(typeId: Int,roadLinks: Seq[RoadLinkForFillTopology], assets: Map[String, Seq[PieceWiseLinearAsset]],
                                  changeSet: Option[ChangeSet] = None): (Seq[PieceWiseLinearAsset], ChangeSet) = {
   assetFiller.fillTopologyChangesGeometry(roadLinks, assets, typeId, changeSet)
  }

  protected override def persistProjectedLinearAssets(newLinearAssets: Seq[PersistedLinearAsset], roadLinks: Seq[RoadLink]): Unit = {
    service.createMultipleLinearAssetsSpeedLimit(newLinearAssets.map(createMassOperationRow))
    LogUtils.time(logger,s"purgeUnknown for newlimits ${newLinearAssets.size}"){
      service.purgeUnknown(newLinearAssets.map(_.linkId).toSet, Seq(), newTransaction = false)
    }
  }
  
  protected override def adjustedSideCode(adjustedSideCodes: Seq[SideCodeAdjustment], oldAssets: Seq[PersistedLinearAsset], roadLinks: Seq[RoadLink]): Unit = {
    service.expireAssets(oldAssets.map(_.id),true, AutoGeneratedUsername.generatedInUpdate,  false)
    val adjusted = adjustedSideCodes.map(_.assetId)
    val assets =  oldAssets.filter(a => adjusted.contains(a.id))
      .map(a => a.copy(sideCode = adjustedSideCodes.find(adj => adj.assetId == a.id).get.sideCode.value))
      .map(createMassOperationRow)
    service.createMultipleLinearAssetsSpeedLimit(assets)
  }
  private def createMassOperationRow(a: PersistedLinearAsset): NewSpeedLimitMassOperation = {
    NewSpeedLimitMassOperation(
      a.createdBy.getOrElse(AutoGeneratedUsername.generatedInUpdate), a.typeId, a.linkId, Measures(a.startMeasure, a.endMeasure).roundMeasures(), SideCode(a.sideCode),
      service.getSpeedLimitValue(a.value), Some(a.timeStamp),
      a.createdDateTime, a.modifiedBy, a.modifiedDateTime, a.linkSource
    )
  }
}
