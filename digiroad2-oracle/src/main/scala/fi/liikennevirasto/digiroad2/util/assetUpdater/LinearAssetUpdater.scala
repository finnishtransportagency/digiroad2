package fi.liikennevirasto.digiroad2.util.assetUpdater

import fi.liikennevirasto.digiroad2.GeometryUtils.Projection
import fi.liikennevirasto.digiroad2.asset.{AutoGeneratedUsername, EuropeanRoads, ExitNumbers, LinkType, SideCode, UnknownLinkType}
import fi.liikennevirasto.digiroad2.client.vvh.ChangeType.{New, isExtensionChange, isReplacementChange, values}
import fi.liikennevirasto.digiroad2.client.{ReplaceInfo, RoadLinkChange, RoadLinkChangeClient, RoadLinkChangeType, RoadLinkClient, RoadLinkInfo}
import fi.liikennevirasto.digiroad2.dao.Queries
import fi.liikennevirasto.digiroad2.dao.linearasset.PostGISLinearAssetDao
import fi.liikennevirasto.digiroad2.linearasset.LinearAssetFiller.{ChangeSet, _}
import fi.liikennevirasto.digiroad2.linearasset._
import fi.liikennevirasto.digiroad2.postgis.PostGISDatabase
import fi.liikennevirasto.digiroad2.service.RoadLinkService
import fi.liikennevirasto.digiroad2.service.linearasset.{LinearAssetOperations, LinearAssetTypes, Measures}
import fi.liikennevirasto.digiroad2.util.{Digiroad2Properties, LinearAssetUtils}
import fi.liikennevirasto.digiroad2._
import fi.liikennevirasto.digiroad2.asset.ConstructionType.UnknownConstructionType
import fi.liikennevirasto.digiroad2.asset.LinkGeomSource.NormalLinkInterface
import fi.liikennevirasto.digiroad2.client.vvh.{ChangeInfo, ChangeType}
import org.slf4j.LoggerFactory

import scala.annotation.tailrec
import scala.util.Try


case class CalculateMValueChangesInfo(assetId: Long, oldId: Option[String], newId: Option[String],
                                      oldStartMeasure: Option[Double], oldEndMeasure: Option[Double],
                                      oldLinksLength: Option[Double],
                                      newStartMeasure: Option[Double],
                                      newEndMeasure: Option[Double],
                                      newLinksLength: Option[Double],
                                      changeType: String = "") {
}

case class AssetLinearReference(id: Long, startMeasure: Double, endMeasure: Double, sideCode: Int)

case class LinkAndLength(linkId: String, length: Double)

class LinearAssetUpdater(service: LinearAssetOperations) {

  def eventBus: DigiroadEventBus = new DummyEventBus
  def roadLinkClient: RoadLinkClient = new RoadLinkClient(Digiroad2Properties.vvhRestApiEndPoint)
  def roadLinkService: RoadLinkService = new RoadLinkService(roadLinkClient, eventBus, new DummySerializer)
  def assetFiller: AssetFiller = new AssetFiller
  def dao: PostGISLinearAssetDao = new PostGISLinearAssetDao()
  def withDynTransaction[T](f: => T): T = PostGISDatabase.withDynTransaction(f)
  val logger = LoggerFactory.getLogger(getClass)
  val roadLinkChangeClient = new RoadLinkChangeClient

  def getRoadlinksAndChanges(typeId: Int) = {
    val latesSuccess = Queries.getLatestSuccessfulSamuutus(typeId)
    roadLinkChangeClient.getRoadLinkChanges(latesSuccess)
  }

  def updateLinearAssets(typeId: Int) = {
    withDynTransaction {
      val (changes) = getRoadlinksAndChanges(typeId)
      updateByRoadLinks2(typeId, changes)
    }
  }

  //TODO Remove after bug in combine and fuse operations is fixed
  def cleanRedundantMValueAdjustments(changeSet: ChangeSet, originalAssets: Seq[PieceWiseLinearAsset]): ChangeSet = {
    val redundantFiltered = changeSet.adjustedMValues.filterNot(adjustment => {
      val originalAsset = originalAssets.find(_.id == adjustment.assetId).get
      originalAsset.startMeasure == adjustment.startMeasure && originalAsset.endMeasure == adjustment.endMeasure
    })
    changeSet.copy(adjustedMValues = redundantFiltered)
  }

  val initChangeSet2 = ChangeSet(droppedAssetIds = Set.empty[Long],
    expiredAssetIds = Set.empty[Long],
    adjustedMValues = Seq.empty[MValueAdjustment],
    adjustedVVHChanges = Seq.empty[VVHChangesAdjustment],
    adjustedSideCodes = Seq.empty[SideCodeAdjustment],
    valueAdjustments = Seq.empty[ValueAdjustment])


  val isDeleted: RoadLinkChange => Boolean = (change: RoadLinkChange) => {
    change.changeType.value == RoadLinkChangeType.Remove.value
  }


  case class GroupedChanges(added: Map[String, Seq[RoadLinkChange]],
                            removed: Map[String, Seq[RoadLinkChange]],
                            split: Map[String, Seq[RoadLinkChange]],
                            merged: Map[String, Seq[RoadLinkChange]],
                            lengthened: Map[String, Seq[RoadLinkChange]],
                            shortened: Map[String, Seq[RoadLinkChange]],
                            versionUpdate: Map[String, Seq[RoadLinkChange]]
                           )


/*  def groupChanges(changes: Seq[RoadLinkChange]): GroupedChanges = {
    val groupedByChange = changes.groupBy(_.changeType)

    def group(a: ((RoadLinkChangeType, Seq[RoadLinkChange])) => Boolean): Map[String, Seq[RoadLinkChange]] = {
      // TODO redo this part of code, first group by old link id and then do filtering
      // TODO this is not optimize for handling large data set. Here we might need convert this into normal for loop. 
      Try(groupedByChange.filter(a).head._2.groupBy(_.oldLink.get.linkId)).getOrElse(Map.empty[String, Seq[RoadLinkChange]])
    }

    //group(recognizeMerger)
    val add = group(recognizeAdd)
    val remove = group(recognizeRemove)
    val split = group(recognizeSplit)
    val merger = group(recognizeMerger)
    val lengthened = group(recognizeLengthening)
    val shortened = group(recognizeShortening)
    val versionUpdate = group(recognizeVersionUpgrade)
    GroupedChanges(add, remove, split, merger, lengthened, shortened, versionUpdate)
  }*/

  def recognizeShortening(change: RoadLinkChange): Boolean = {
    change.changeType == RoadLinkChangeType.Replace && recognizeShorteningMeter(change)
  }

  def recognizeLengthening(change: RoadLinkChange): Boolean = {
    change.changeType == RoadLinkChangeType.Replace && recognizeLengtheningMeter(change)
  }

  def recognizeAdd(change: RoadLinkChange): Boolean = {
    change.changeType == RoadLinkChangeType.Split
  }

  def recognizeRemove(change:RoadLinkChange): Boolean = {
    change.changeType == RoadLinkChangeType.Remove
  }
  def recognizeSplit(change: RoadLinkChange): Boolean = {
    change.changeType == RoadLinkChangeType.Split
  }

  def recognizeLengtheningMeter(change: RoadLinkChange): Boolean = {
    val oldMValue = change.oldLink.head.linkLength
    val newMValue = change.newLinks.head.linkLength
    if (oldMValue < newMValue) {
      true
    } else false
  }

  def recognizeShorteningMeter(change: RoadLinkChange): Boolean = {
    val oldMValue = change.oldLink.head.linkLength
    val newMValue = change.newLinks.head.linkLength
    if (oldMValue > newMValue) {
      true
    } else false
  }

  def splitLinkId(linkId: String): (String, Int) = {
    val split = linkId.split(":")
    (split(0), split(1).toInt)
  }
  def recognizeMerger(change: RoadLinkChange): Boolean = {
    change.changeType == RoadLinkChangeType.Replace
  }
  def recognizeVersionUpgrade(change: RoadLinkChange): Boolean = {
    change.changeType == RoadLinkChangeType.Replace && checkId(change)
  }
  def checkId(change: RoadLinkChange): Boolean = {
    val oldId = splitLinkId(change.oldLink.get.linkId)._1
    val newId = splitLinkId(change.newLinks.head.linkId)._1
    if (oldId == newId) {
      true
    } else false
  }
  def toRoadLinkForFilltopology(roadLink: RoadLinkInfo): RoadLinkForFiltopology = {
    RoadLinkForFiltopology(linkId = roadLink.linkId, length = roadLink.linkLength, trafficDirection = roadLink.trafficDirection /*non override version */ , administrativeClass = roadLink.adminClass /*non override version */ ,
      linkSource = NormalLinkInterface, linkType = UnknownLinkType, constructionType = UnknownConstructionType, geometry = roadLink.geometry) // can there be link of different sourse ?
  }
  def updateByRoadLinks2(typeId: Int, changes: Seq[RoadLinkChange]) = {

    val oldIds = changes.filterNot(isDeleted).map(_.oldLink.get.linkId)
    val deletedLinks = changes.filter(isDeleted).map(_.oldLink.get.linkId)
    val existingAssets = service.fetchExistingAssetsByLinksIdsString(typeId, oldIds.toSet, deletedLinks.toSet, newTransaction = false)

    val initChangeSet = ChangeSet(droppedAssetIds = Set.empty[Long],
      expiredAssetIds = existingAssets.filter(asset => deletedLinks.contains(asset.linkId)).map(_.id).toSet.filterNot(_ == 0L),
      adjustedMValues = Seq.empty[MValueAdjustment],
      adjustedVVHChanges = Seq.empty[VVHChangesAdjustment],
      adjustedSideCodes = Seq.empty[SideCodeAdjustment],
      valueAdjustments = Seq.empty[ValueAdjustment])

    // TODO convert this into loop, make fillNewRoadLinksWithPreviousAssetsData2 work as loop which return new asset and change info
    //val grouped = groupChanges(changes)

    val (projectedAssets, changedSet) = fillNewRoadLinksWithPreviousAssetsData2(existingAssets, changes, initChangeSet)
    val convertedLink = changes.flatMap(_.newLinks.map(toRoadLinkForFilltopology))
    val groupedAssets = assetFiller.toLinearAssetsOnMultipleLinks(projectedAssets, convertedLink).groupBy(_.linkId)
    val adjusted = adjustLinearAssetsOnChangesGeometry(convertedLink, groupedAssets, typeId, Some(changedSet))
    persistProjectedLinearAssets(adjusted._1.map(convertToPersisted).filter(_.id == 0L))

  }


  def isInMiddle(asset: PersistedLinearAsset, linkMeasure: Double): Boolean = {
    asset.startMeasure > 0 && asset.endMeasure < linkMeasure
  }
  def isPartialSlicedFromStart(asset: PersistedLinearAsset, linkMeasure: Double): Boolean = {
    asset.startMeasure  != 0 && asset.endMeasure == linkMeasure
  }
  def isPartialSlicedFromEnd(asset: PersistedLinearAsset, linkMeasure: Double): Boolean = {
    asset.startMeasure  == 0 && asset.endMeasure < linkMeasure
  }
  def isFullLinkLength(asset: PersistedLinearAsset, linkMeasure: Double): Boolean = {
   asset.startMeasure == 0 && asset.endMeasure == linkMeasure
  }


  def sliceLoop(change: RoadLinkChange, assetsAll: Seq[PersistedLinearAsset],changeSets:ChangeSet): Seq[(PersistedLinearAsset, ChangeSet)] = {
    val linkWhichIsSplitted = change.oldLink.get.linkId
    val assets = assetsAll.filter(p => linkWhichIsSplitted.contains(p.linkId))

    val valuesAndSideCodesAreSame = assets.flatMap(_.value).toSet.size == 1 && assets.map(_.sideCode).toSet.size == 1
    val assetLengthStatus = assets.map(p2 => isFullLinkLength(p2, change.oldLink.get.linkLength)).toSet

    val allAreFullLinkLength = assetLengthStatus.size == 1 && assetLengthStatus.head
    if (valuesAndSideCodesAreSame && allAreFullLinkLength) {
      val assets = assetsAll.filter(_.linkId == change.oldLink.get.linkId)
      // check situation where there is split asset when link is split
      val projected = change.replaceInfo.map(replaceInfo => { // slicing
        assets.head.copy(id = 0, linkId = replaceInfo.oldLinkId, startMeasure = replaceInfo.oldFromMValue, endMeasure = replaceInfo.oldToMValue)
      }).flatMap(asset => {
        val mapping = convertToForCalculation(change, asset)
        val findProjection = mapping.head
        Seq(projecting(changeSets, asset, findProjection, testNoAssetExistsOnTarget))
      })
      val returnedChangeSet = foldChangeSet(projected.map(_._2), changeSets)
      val update = returnedChangeSet.copy(expiredAssetIds = returnedChangeSet.expiredAssetIds ++ assets.map(_.id))
      // optimize so that there is no nested seq , check in end
      projected.map(p => (p._1, update))
    } else {

      // if asset fall totally into new link do notthing,

      // if asset fall partially, slice 
      // sliced part check where it fall

      // partition asset which endMeasure is greater than oldFromMValue
      // slice these asset to end at oldFromMValue
      // create new part which has startMValue as oldFromMValue
      // shift these into next links
      // Repeat operation on next links

      val assets = assetsAll.filter(_.linkId == change.oldLink.get.linkId)

      def selectNearestReplaceInfo(replaceInfo: ReplaceInfo, asset: PersistedLinearAsset): Boolean = {
        val condition = asset.linkId == replaceInfo.oldLinkId && asset.endMeasure >= replaceInfo.oldToMValue || asset.endMeasure <= replaceInfo.oldToMValue && asset.startMeasure >= replaceInfo.oldFromMValue
        println(s"Condition selectNearestReplaceInfo  status: $condition")
        println(s"evaluate asset ${asset.id} ,old link id: ${asset.linkId}")
        println(s"oldFrom: ${replaceInfo.oldFromMValue}, oldTo: ${replaceInfo.oldToMValue}, asset start: ${asset.startMeasure}, asset end: ${asset.endMeasure}")
        if (!condition) {
          condition
        } else condition
      }

      def partitioner(asset: PersistedLinearAsset, change: RoadLinkChange): Boolean = {
        // order list by oldToMValue and start looking for right replace info by looking first highest number
        // and then checking lower number until correct one is found.
        val sortedInfo = change.replaceInfo.sortBy(_.oldToMValue).reverse
        val selectInfo = sortedInfo.find(selectNearestReplaceInfo(_, asset)).get
        val condition = asset.endMeasure >= selectInfo.oldToMValue && asset.startMeasure >= selectInfo.oldFromMValue
        println(s"Condition partitioner  status: $condition")
        println(s"evaluate asset ${asset.id} old link id: ${asset.linkId}")
        println(s"oldFrom: ${selectInfo.oldFromMValue}, oldTo: ${selectInfo.oldToMValue}, asset start: ${asset.startMeasure}, asset end: ${asset.endMeasure}")
        if (condition) {
          condition
        } else condition
      }

      def slicer(assets: Seq[PersistedLinearAsset], change: RoadLinkChange, cycle: Int = 0): Seq[PersistedLinearAsset] = {
        val assetGoOver = assets.partition(partitioner(_, change))
        val sliced = assetGoOver._1.flatMap(a1 => {
          // order list by oldToMValue and start looking for right replace info by looking first highest number
          // and then checking lower number until correct one is found.
          val selectInfo = change.replaceInfo.sortBy(_.oldToMValue).reverse.find(r => a1.linkId == r.oldLinkId && a1.endMeasure >= r.oldToMValue && a1.startMeasure >= r.oldFromMValue).get
          val shorted = a1.copy(endMeasure = selectInfo.oldToMValue)
          val newPart = a1.copy(id = 0, startMeasure = selectInfo.oldToMValue)
          val shortedLength = shorted.endMeasure - shorted.startMeasure
          val newPartLength = newPart.endMeasure - newPart.startMeasure

          val shortedFilter = if (shortedLength > 0) {
            Option(shorted)
          } else None

          val newPartFilter = if (newPartLength > 0) {
            Option(newPart)
          } else None

          println(s"asset old start ${shorted.startMeasure}, asset end ${shorted.endMeasure}")
          println(s"asset new start ${newPart.startMeasure} asset end ${newPart.endMeasure}")

          (shortedFilter, newPartFilter) match {
            case (None, None) => Seq()
            case (Some(shortedSome), None) => Seq(shortedSome)
            case (None, Some(newParSome)) => Seq(newParSome)
            case (Some(shortedSome), Some(newPartSome)) => Seq(shortedSome, newPartSome)
          }
        })
        (sliced ++ assetGoOver._2.filterNot(a => sliced.map(_.id).toSet.contains(a.id)))
      }

      val sliced: Seq[PersistedLinearAsset] = slicer(assets, change)

      sliced.flatMap(asset => {
        convertToForCalculation(change, asset).map(dataForCalculation => {
          projecting(changeSets, asset, dataForCalculation, testNoAssetExistsOnTarget)
        })
      })
    }
  }

  protected def fillNewRoadLinksWithPreviousAssetsData2(assetsAll: Seq[PersistedLinearAsset], changes: Seq[RoadLinkChange], changeSets: ChangeSet): (Seq[PersistedLinearAsset], ChangeSet) = {
    val result = changes.flatMap(change => {
      val oldLink = change.oldLink.get
      val oldId = oldLink.linkId
      val assets = assetsAll.filter(_.linkId == oldId)
      change.changeType match {
        case RoadLinkChangeType.Replace =>
          val isInMiddle = assets.size == 1 && isInMiddle(assets.head, oldLink.linkLength)
          assets.flatMap(asset => {
            convertToForCalculation(change, asset, isInMiddle).map(dataForCalculation => {
              projecting(changeSets, asset, dataForCalculation, testAssetsContainSegment)
            })
          })
        case RoadLinkChangeType.Split => sliceLoop(change, assetsAll, changeSets)
        case RoadLinkChangeType.Remove => Seq.empty[(PersistedLinearAsset, ChangeSet)]
        case RoadLinkChangeType.Add => Seq.empty[(PersistedLinearAsset, ChangeSet)]
      }
    })

    result.map(_._1).groupBy(_.linkId).map(link=>{
      val assetsOrdered = link._2.sortBy(_.endMeasure)
      // chect for consetive of similar values and side code in each link, 
      // merger these and expire old.
      // order by link id and then by endmeasure
    })
    
    (result.map(_._1), foldChangeSet(result.map(_._2),changeSets))
  }
  
  def foldChangeSet (mergedChangeSet: Seq[ChangeSet],foldTo:ChangeSet):  ChangeSet ={
    mergedChangeSet.foldLeft(foldTo) { (a, z) =>
      a.copy(
        adjustedMValues     = a.adjustedMValues     ++ z.adjustedMValues,
        adjustedVVHChanges  = a.adjustedVVHChanges  ++ z.adjustedVVHChanges,
        adjustedSideCodes   = a.adjustedSideCodes   ++ z.adjustedSideCodes,
        expiredAssetIds     = a.expiredAssetIds     ++ z.expiredAssetIds,
        valueAdjustments    = a.valueAdjustments    ++ z.valueAdjustments
      );
    }
  } 
  
  private def projecting(changeSets: ChangeSet, asset: PersistedLinearAsset, p1: (CalculateMValueChangesInfo,InfoForCalculation), condition: (PersistedLinearAsset, String, String, Double, Double) => Boolean) = {
    
    val changeInfo = p1._1
    val additionalInfo = p1._2
    val projected = projectAssetsConditionally(changeInfo, asset, condition)
    projectLinearAsset(asset.copy(linkId = changeInfo.newId.get), LinkAndLength(changeInfo.newId.get, changeInfo.newLinksLength.get), projected.getOrElse(throw new Exception(s"Projection returned Nothing ,link: ${changeInfo.newId}")),additionalInfo, changeSets)
  }
  def selectCorrectReplaceInfo(replaceInfo: ReplaceInfo, asset: PersistedLinearAsset): Boolean = {
    val condition = replaceInfo.oldLinkId == asset.linkId && replaceInfo.oldFromMValue <= asset.startMeasure && replaceInfo.oldToMValue >= asset.endMeasure
    println(s"Condition status: $condition")
    if(!condition){
      println(s"evaluate asset ${asset.id}, old linkId: ${asset.linkId}")
      println(s"oldFrom: ${replaceInfo.oldFromMValue}, oldTo: ${replaceInfo.oldToMValue}, asset start: ${asset.startMeasure}, asset end: ${asset.endMeasure}")
      condition
    } else condition
  }
  
  private def convertToForCalculation(changes: RoadLinkChange, asset: PersistedLinearAsset,inMiddleOfLink:Boolean =false) = {
      val info = changes.replaceInfo.find(selectCorrectReplaceInfo(_,asset)).getOrElse(throw new Exception("Did not found replace info for asset"))
      val link = changes.newLinks.find(_.linkId == info.newLinkId).get
      
      println(s"is full length: ${isFullLinkLength(asset, changes.oldLink.get.linkLength)}")
      
      val (isPartiallySlicedFromEnd,isPartiallySlicedFromStart) =(isPartialSlicedFromEnd(asset,changes.oldLink.get.linkLength),isPartialSlicedFromStart(asset,changes.oldLink.get.linkLength))
      
      val additionalInfo = if (isFullLinkLength(asset, changes.oldLink.get.linkLength)) {InfoForCalculation(fullLink = true) }else {
        (isPartiallySlicedFromEnd,isPartiallySlicedFromStart,inMiddleOfLink) match {
          case (false,true,false) => InfoForCalculation(startFromEndLink = true)
          case (true,false,false) => InfoForCalculation(startFromBegindLink = true)
          case (false,false,true) => InfoForCalculation( inMiddleOfLink = true)
          case _ =>InfoForCalculation()
        }
      }
       Some( (CalculateMValueChangesInfo(
          asset.id,
          Some(info.oldLinkId),
          Some(info.newLinkId),
          Some(info.oldFromMValue),
          Some(info.oldToMValue),
          Some(changes.oldLink.get.linkLength),
          Some(info.newFromMValue),
          Some(info.newToMValue),
          Some(link.linkLength)
        ),additionalInfo))
  }
  def adjustLinearAssetsOnChangesGeometry(roadLinks: Seq[RoadLinkForFiltopology], linearAssets: Map[String, Seq[PieceWiseLinearAsset]],
                                          typeId: Int, changeSet: Option[ChangeSet] = None, counter: Int = 1): (Seq[PieceWiseLinearAsset], ChangeSet) = {
    
    // TODO is there need validate whole asset network?
     val (filledTopology, changedSet) = assetFiller.fillTopologyChangesGeometry(roadLinks, linearAssets, typeId, changeSet)
    val adjustmentsChangeSet = cleanRedundantMValueAdjustments(changedSet, linearAssets.values.flatten.toSeq)
        adjustmentsChangeSet.isEmpty match { //  Validate that there is no infinity loop 
          case true => filledTopology
          case false if counter > 3 =>
            updateChangeSet(adjustmentsChangeSet)
            filledTopology
          case false if counter <= 3 =>
            updateChangeSet(adjustmentsChangeSet)
            val linearAssetsToAdjust = filledTopology.filterNot(asset => asset.id <= 0 && asset.value.isEmpty)
            adjustLinearAssetsOnChangesGeometry(roadLinks, linearAssetsToAdjust.groupBy(_.linkId), typeId, None, counter + 1)
        }

    //updateChangeSet(changeSet.get)
    //(linearAssets.values.flatten.toSeq, changeSet.get)
    (filledTopology, adjustmentsChangeSet)
  }

  def convertToPersisted(asset:PieceWiseLinearAsset): PersistedLinearAsset = {
    PersistedLinearAsset(asset.id,asset.linkId,asset.sideCode.value,
      asset.value,asset.startMeasure,asset.endMeasure,asset.createdBy,
      asset.createdDateTime,asset.modifiedBy,asset.modifiedDateTime,asset.expired,asset.typeId,asset.timeStamp,
      asset.geomModifiedDate,asset.linkSource,asset.verifiedBy,asset.verifiedDate,asset.informationSource)
  }


  def updateChangeSet(changeSet: ChangeSet): Unit = {
    dao.floatLinearAssets(changeSet.droppedAssetIds)

    if (changeSet.adjustedMValues.nonEmpty)
      println("Saving adjustments for asset/link ids=" + changeSet.adjustedMValues.map(a => "" + a.assetId + "/" + a.linkId).mkString(", "))

    changeSet.adjustedMValues.foreach { adjustment =>
      dao.updateMValues(adjustment.assetId, adjustment.linkId, (adjustment.startMeasure, adjustment.endMeasure))
    }

    if (changeSet.adjustedVVHChanges.nonEmpty)
      println("Saving adjustments for asset/link ids=" + changeSet.adjustedVVHChanges.map(a => "" + a.assetId + "/" + a.linkId).mkString(", "))

    changeSet.adjustedVVHChanges.foreach { adjustment =>
      dao.updateMValuesChangeInfo(adjustment.assetId, adjustment.linkId, (adjustment.startMeasure, adjustment.endMeasure), adjustment.timeStamp, AutoGeneratedUsername.generatedInUpdate)
    }
    val ids = changeSet.expiredAssetIds.toSeq
    if (ids.nonEmpty)
      println("Expiring ids " + ids.mkString(", "))
    ids.foreach(dao.updateExpiration(_, expired = true, AutoGeneratedUsername.generatedInUpdate))

    if (changeSet.adjustedSideCodes.nonEmpty)
      println("Saving SideCode adjustments for asset/link ids=" + changeSet.adjustedSideCodes.map(a => "" + a.assetId).mkString(", "))

    changeSet.adjustedSideCodes.foreach { adjustment =>
      adjustedSideCode(adjustment)
    }

    if (changeSet.valueAdjustments.nonEmpty)
      println("Saving value adjustments for assets: " + changeSet.valueAdjustments.map(a => "" + a.asset.id).mkString(", "))
    changeSet.valueAdjustments.foreach { adjustment =>
      service.updateWithoutTransaction(Seq(adjustment.asset.id), adjustment.asset.value.get, adjustment.asset.modifiedBy.get)

    }
  }

  def persistProjectedLinearAssets(newLinearAssets: Seq[PersistedLinearAsset]): Unit = {
    if (newLinearAssets.nonEmpty)
      logger.info("Saving projected linear assets")

    def getValuePropertyId(value: Option[Value], typeId: Int) = {
      value match {
        case Some(NumericValue(intValue)) =>
          LinearAssetTypes.numericValuePropertyId
        case Some(TextualValue(textValue)) =>
          LinearAssetTypes.getValuePropertyId(typeId)
        case _ => ""
      }
    }

    println(s"new assets count: ${newLinearAssets.size}")

    val (toInsert, toUpdate) = newLinearAssets.partition(_.id == 0L)
    println(s"insert assets count: ${toInsert.size}")
    println(s"update assets count: ${toUpdate.size}")
    val roadLinks = roadLinkService.getRoadLinksAndComplementariesByLinkIds(newLinearAssets.map(_.linkId).toSet, newTransaction = false)
    if (toUpdate.nonEmpty) {
      val toUpdateText = toUpdate.filter(a =>
        Set(EuropeanRoads.typeId, ExitNumbers.typeId).contains(a.typeId))

      val groupedNum = toUpdate.filterNot(a => toUpdateText.contains(a)).groupBy(a => getValuePropertyId(a.value, a.typeId)).filterKeys(!_.equals(""))
      val groupedText = toUpdateText.groupBy(a => getValuePropertyId(a.value, a.typeId)).filterKeys(!_.equals(""))

      val persisted = (groupedNum.flatMap(group => dao.fetchLinearAssetsByIds(group._2.map(_.id).toSet, group._1)).toSeq ++
        groupedText.flatMap(group => dao.fetchAssetsWithTextualValuesByIds(group._2.map(_.id).toSet, group._1)).toSeq).groupBy(_.id)

      updateProjected(toUpdate, persisted)
      if (newLinearAssets.nonEmpty)
        logger.info("Updated ids/linkids " + toUpdate.map(a => (a.id, a.linkId)))
    }
    toInsert.foreach { linearAsset =>
      val roadlink = roadLinks.find(_.linkId == linearAsset.linkId)
      val id =
        (linearAsset.createdBy, linearAsset.createdDateTime) match {
          case (Some(createdBy), Some(createdDateTime)) =>
            dao.createLinearAsset(linearAsset.typeId, linearAsset.linkId, linearAsset.expired, linearAsset.sideCode,
              Measures(linearAsset.startMeasure, linearAsset.endMeasure), AutoGeneratedUsername.generatedInUpdate, linearAsset.timeStamp,
              service.getLinkSource(roadlink), fromUpdate = true, Some(createdBy), Some(createdDateTime), linearAsset.verifiedBy, linearAsset.verifiedDate, geometry = service.getGeometry(roadlink))
          case _ =>
            dao.createLinearAsset(linearAsset.typeId, linearAsset.linkId, linearAsset.expired, linearAsset.sideCode,
              Measures(linearAsset.startMeasure, linearAsset.endMeasure), AutoGeneratedUsername.generatedInUpdate, linearAsset.timeStamp,
              service.getLinkSource(roadlink), geometry = service.getGeometry(roadlink))
        }

      linearAsset.value match {
        case Some(NumericValue(intValue)) =>
          dao.insertValue(id, LinearAssetTypes.numericValuePropertyId, intValue)
        case Some(TextualValue(textValue)) =>
          dao.insertValue(id, LinearAssetTypes.getValuePropertyId(linearAsset.typeId), textValue)
        case _ => None
      }
    }
    if (toInsert.nonEmpty)
      logger.info("Added assets for linkids " + newLinearAssets.map(_.linkId))
  }

  protected def updateProjected(toUpdate: Seq[PersistedLinearAsset], persisted: Map[Long, Seq[PersistedLinearAsset]]) = {
    def valueChanged(assetToPersist: PersistedLinearAsset, persistedLinearAsset: Option[PersistedLinearAsset]) = {
      !persistedLinearAsset.exists(_.value == assetToPersist.value)
    }

    toUpdate.foreach { linearAsset =>
      val persistedLinearAsset = persisted.getOrElse(linearAsset.id, Seq()).headOption
      val id = linearAsset.id
      if (valueChanged(linearAsset, persistedLinearAsset)) {
        linearAsset.value match {
          case Some(NumericValue(intValue)) =>
            dao.updateValue(id, intValue, LinearAssetTypes.numericValuePropertyId, AutoGeneratedUsername.generatedInUpdate)
          case Some(TextualValue(textValue)) =>
            dao.updateValue(id, textValue, LinearAssetTypes.getValuePropertyId(linearAsset.typeId), AutoGeneratedUsername.generatedInUpdate)
          case _ => None
        }
      }
    }
  }

  protected def fillNewRoadLinksWithPreviousAssetsData(roadLinks: Seq[RoadLink], assetsToUpdate: Seq[PersistedLinearAsset],
                                                       currentAssets: Seq[PersistedLinearAsset], changes: Seq[RoadLinkChange],
                                                       changeSet: ChangeSet, existingAssets: Seq[PersistedLinearAsset]): (Seq[PersistedLinearAsset], ChangeSet) = {


    /*val (replacementChanges, otherChanges) = changes.partition(isReplacementChange)
    val reverseLookupMap = replacementChanges.filterNot(c=>c.oldId.isEmpty || c.newId.isEmpty).map(c => c.newId.get -> c).groupBy(_._1).mapValues(_.map(_._2))

    val extensionChanges = otherChanges.filter(isExtensionChange).flatMap(
      ext => reverseLookupMap.getOrElse(ext.newId.getOrElse(LinkId.Unknown.value), Seq()).flatMap(
        rep => addSourceRoadLinkToChangeInfo(ext, rep)))

    val fullChanges = extensionChanges ++ replacementChanges


    val linearAssetsAndChanges = mapReplacementProjections(assetsToUpdate, currentAssets, roadLinks, fullChanges).flatMap {
      case (asset, (Some(roadLink), Some(projection))) =>
        val (linearAsset, changes) = projectLinearAsset(asset, roadLink, projection, changeSet)
        Some((linearAsset, changes))
      case _ => None
    }

    val linearAssets = linearAssetsAndChanges.map(_._1)
    val generatedChangeSet = linearAssetsAndChanges.map(_._2)
    val changeSetF = if (generatedChangeSet.nonEmpty) { generatedChangeSet.last } else { changeSet }
    val newLinearAsset = if((linearAssets ++ existingAssets).nonEmpty) {
      Seq()
    } else Seq()

    (linearAssets ++ newLinearAsset, changeSetF)*/
    (Seq(), initChangeSet2)
  }

  private def projectAssetsConditionally(change: CalculateMValueChangesInfo, asset: PersistedLinearAsset,
                                         condition: (PersistedLinearAsset, String, String, Double, Double) => Boolean): Option[Projection] = {
    (change.oldId, change.newId, change.oldStartMeasure, change.oldEndMeasure, change.newStartMeasure, change.newEndMeasure) match {
      case (Some(from), Some(to), Some(oldStart: Double), Some(oldEnd: Double), Some(newStart: Double), Some(newEnd: Double)) => {
        println(s"condition status: ${condition(asset, from, to, oldStart, oldEnd)} ") // TODO check if we can remove this totally and do checking somewhere else
        condition(asset, from, to, oldStart, oldEnd) match {
          case true => {
            println(s"old Link: $from, asset: ${asset.id} oldStart:$oldStart oldEnd:$oldEnd newStart:$newStart newEnd:$newEnd");
            Some(Projection(oldStart, oldEnd, newStart, newEnd))
          }
          case false =>
            None
        }
      }
      case _ =>
        None
    }
  }

  /*  private def projectAssetsConditionally2(change: CalculateMValueChangesInfo, asset: PersistedLinearAsset): Option[Projection] = {
  
  
      val from = change.oldId.get
      val to = change.newId.get
      val oldStart = change.oldStartMeasure.get
      val oldEnd = change.oldEndMeasure.get
      val oldLinksLength = change.oldLinksLength.get
      val newStart = change.newStartMeasure.get
      val newEnd = change.newEndMeasure.get
      val newLinksLength = change.oldLinksLength.get
          println(s"old Link:$from, asset: ${asset.id} oldStart:$oldStart oldEnd:$oldEnd newStart:$newStart newEnd:$newEnd");
          Some(Projection(oldStart, oldEnd, newStart, newEnd))
          
          if (asset.endMeasure ==  oldLinksLength) {
            Some(Projection(oldStart, oldEnd, newStart, newLinksLength))
          }
          
        
    }
    */
  
  //TODO check if this is needed?
  private def testNoAssetExistsOnTarget(assets: PersistedLinearAsset, oldId: String, newId: String, mStart: Double, mEnd: Double): Boolean = {
    // !assets.exists(l => l.linkId == oldId && GeometryUtils.overlaps((l.startMeasure,l.endMeasure),(mStart,mEnd)))

    true
  }

  private def testAssetsContainSegment(asset: PersistedLinearAsset, oldId: String, newId: String, mStart: Double, mEnd: Double): Boolean = {
    GeometryUtils.covered((asset.startMeasure, asset.endMeasure), (mStart, mEnd))
  }

  def adjustedSideCode(adjustment: SideCodeAdjustment): Unit = {
    val oldAsset = service.getPersistedAssetsByIds(adjustment.typeId, Set(adjustment.assetId), newTransaction = false).headOption
      .getOrElse(throw new IllegalStateException("Old asset " + adjustment.assetId + " of type " + adjustment.typeId + " no longer available"))

    val roadLink = roadLinkService.getRoadLinkAndComplementaryByLinkId(oldAsset.linkId, newTransaction = false)
      .getOrElse(throw new IllegalStateException("Road link " + oldAsset.linkId + " no longer available"))

    service.expireAsset(oldAsset.typeId, oldAsset.id, AutoGeneratedUsername.generatedInUpdate, expired = true, newTransaction = false)

    val oldAssetValue = oldAsset.value.getOrElse(throw new IllegalStateException("Value of the old asset " + oldAsset.id + " of type " + oldAsset.typeId + " is not available"))

    service.createWithoutTransaction(oldAsset.typeId, oldAsset.linkId, oldAssetValue, adjustment.sideCode.value,
      Measures(oldAsset.startMeasure, oldAsset.endMeasure), AutoGeneratedUsername.generatedInUpdate, LinearAssetUtils.createTimeStamp(),
      Some(roadLink), false, Some(AutoGeneratedUsername.generatedInUpdate), None, oldAsset.verifiedBy, oldAsset.informationSource.map(_.value))

  }
  
  
  case class InfoForCalculation(
                               fullLink:Boolean=false,
                               startFromEndLink:Boolean=false,
                               startFromBegindLink:Boolean=false,
                               inMiddleOfLink:Boolean=false
                               
                               )
  
  /**
    * calculator is based on old change info, does not totally work anymore. Need to add math for splitting and joining, work with lengthening and shortening.
    *
    * @param asset
    * @param projection
    * @param roadLinkLength
    * @return
    */
  def calculateNewMValuesAndSideCode(asset: AssetLinearReference, projection: Projection, roadLinkLength: Double,info:InfoForCalculation=InfoForCalculation()) = {
    val oldLength = projection.oldEnd - projection.oldStart
    val newLength = projection.newEnd - projection.newStart

    // TODO add more information for calculation
    // TODO what is start point and endpoint
    // TODO is flipped
    // TODO is full length
    
    val projectionStartDiff = projection.oldStart - projection.newStart
    val projectionEndDiff = projection.oldEnd - projection.newEnd

    val newStart = asset.startMeasure - projectionStartDiff
    val newEnd = asset.endMeasure - projectionStartDiff 
    
    if (newStart>newEnd) {
      throw new Exception(s"invalid meters start: ${newStart} , end ${newEnd}")
    }
    
    println(s"new start $newStart, new end $newEnd, projectionStartDiff number $projectionStartDiff, projectionStartDiff number $projectionEndDiff")
    
    println(s"Directon changes: ${GeometryUtils.isDirectionChangeProjection(projection)}")
    // Test if the direction has changed -> side code will be affected, too
    if (GeometryUtils.isDirectionChangeProjection(projection)) {
      val newSideCode = SideCode.apply(asset.sideCode) match {
        case (SideCode.AgainstDigitizing) => SideCode.TowardsDigitizing.value
        case (SideCode.TowardsDigitizing) => SideCode.AgainstDigitizing.value
        case _ => asset.sideCode
      }
      // Test if asset is affected by projection
      if (asset.endMeasure <= projection.oldStart || asset.startMeasure >= projection.oldEnd)
        (asset.startMeasure, asset.endMeasure, newSideCode)
      else
        (Math.min(roadLinkLength, Math.max(0.0, newStart)), Math.max(0.0, Math.min(roadLinkLength, newEnd)), newSideCode)
    } else {
      // Test if asset is affected by projection
      if (asset.endMeasure <= projection.oldStart || asset.startMeasure >= projection.oldEnd) {
        (asset.startMeasure, asset.endMeasure, asset.sideCode)
      } else {
        
        val start = Math.min(roadLinkLength, Math.max(0.0, newStart)) // take new start if it is greater than zero and smaller than roadLinkLength
        val end = Math.max(0.0, Math.min(roadLinkLength, newEnd))  // take new end if it is greater than zero and smaller than roadLinkLength
        //val start = newStart // take new start if it is greater than zero and smaller than roadLinkLength
        //val end = newEnd// take new end if it is greater than zero and smaller than roadLinkLength
        
        println(s"asset: ${asset.id}")
        println(s"link length: $roadLinkLength")
        println(s"old start ${asset.startMeasure}, old end ${asset.endMeasure}, old length ${asset.endMeasure-asset.startMeasure}, old projection length $oldLength")
        println(s"new start $start, new end $end, new length ${end-start}, new projection length $newLength")
        info match {
          case InfoForCalculation(true, false, false, false) => (0, roadLinkLength, asset.sideCode)
          case InfoForCalculation(false, true, false, false) => (asset.startMeasure, roundMeasure(end), asset.sideCode) //lenthen end
          case InfoForCalculation(false, false, true, false) => (roundMeasure(start), asset.endMeasure, asset.sideCode) //lenthen begind
          case InfoForCalculation(false, false, false, true) => (asset.startMeasure, asset.endMeasure, asset.sideCode)
          case _ => (roundMeasure(start), roundMeasure(end), asset.sideCode)
        }
      }
    }
  }

  def roundMeasure(measure: Double, numberOfDecimals: Int = 3): Double = {
    val exponentOfTen = Math.pow(10, numberOfDecimals)
    Math.round(measure * exponentOfTen).toDouble / exponentOfTen
  }

  def projectLinearAsset(asset: PersistedLinearAsset, to: LinkAndLength, projection: Projection,additionalInfo: InfoForCalculation, changedSet: ChangeSet): (PersistedLinearAsset, ChangeSet) = {
    val newLinkId = to.linkId
    val assetId = asset.linkId match {
      case to.linkId => asset.id
      case _ => 0
    }
    val (newStart, newEnd, newSideCode) = calculateNewMValuesAndSideCode(AssetLinearReference(asset.id, asset.startMeasure, asset.endMeasure, asset.sideCode), projection, to.length,additionalInfo)

    val changeSet = assetId match {
      case 0 => changedSet
      case _ => changedSet.copy(adjustedVVHChanges = changedSet.adjustedVVHChanges ++ Seq(VVHChangesAdjustment(assetId, newLinkId, newStart, newEnd, projection.timeStamp)),
        adjustedSideCodes =
          if (asset.sideCode == newSideCode) {
            changedSet.adjustedSideCodes
          } else {
            changedSet.adjustedSideCodes ++ Seq(SideCodeAdjustment(assetId, SideCode.apply(newSideCode), asset.typeId))
          }
      )
    }

    (PersistedLinearAsset(id = assetId, linkId = newLinkId, sideCode = newSideCode,
      value = asset.value, startMeasure = newStart, endMeasure = newEnd,
      createdBy = asset.createdBy, createdDateTime = asset.createdDateTime, modifiedBy = asset.modifiedBy,
      modifiedDateTime = asset.modifiedDateTime, expired = false, typeId = asset.typeId,
      timeStamp = projection.timeStamp, geomModifiedDate = None, linkSource = asset.linkSource, verifiedBy = asset.verifiedBy, verifiedDate = asset.verifiedDate,
      informationSource = asset.informationSource), changeSet)
  }
}
