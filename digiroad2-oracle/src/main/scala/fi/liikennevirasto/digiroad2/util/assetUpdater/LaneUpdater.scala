package fi.liikennevirasto.digiroad2.util.assetUpdater

import fi.liikennevirasto.digiroad2.GeometryUtils.Projection
import fi.liikennevirasto.digiroad2.asset.SideCode.switch
import fi.liikennevirasto.digiroad2.asset.{AutoGeneratedUsername, Lanes, SideCode, TractorRoad, TrafficDirection}
import fi.liikennevirasto.digiroad2.client.{RoadLinkChangeType, _}
import fi.liikennevirasto.digiroad2.client.viite.SearchViiteClient
import fi.liikennevirasto.digiroad2.dao.Queries
import fi.liikennevirasto.digiroad2.dao.RoadLinkOverrideDAO.TrafficDirectionDao
import fi.liikennevirasto.digiroad2.dao.lane.{AutoProcessedLanesWorkListItem, LaneWorkListItem}
import fi.liikennevirasto.digiroad2.lane.LaneFiller._
import fi.liikennevirasto.digiroad2.lane.LaneNumber.isMainLane
import fi.liikennevirasto.digiroad2.lane._
import fi.liikennevirasto.digiroad2.postgis.PostGISDatabase
import fi.liikennevirasto.digiroad2.service.lane.{AutoProcessedLanesWorkListService, LaneService, LaneWorkListService}
import fi.liikennevirasto.digiroad2.service.{RoadAddressService, RoadLinkService}
import fi.liikennevirasto.digiroad2.util.assetUpdater.ChangeTypeReport.{Creation, Deletion, Divided, Replaced}
import fi.liikennevirasto.digiroad2.util.{Digiroad2Properties, LaneUtils, LogUtils, MainLanePopulationProcess, Parallel}
import fi.liikennevirasto.digiroad2._
import fi.liikennevirasto.digiroad2.Point
import fi.liikennevirasto.digiroad2.client.RoadLinkChangeType.Add
import fi.liikennevirasto.digiroad2.linearasset.RoadLink
import fi.liikennevirasto.digiroad2.util.CustomIterableOperations.IterableOperation
import org.apache.http.impl.client.HttpClientBuilder
import org.joda.time.DateTime
import org.json4s.JsonAST.JObject
import org.json4s.jackson.compactJson
import org.slf4j.LoggerFactory

import java.text.SimpleDateFormat
import java.util.concurrent.atomic.AtomicInteger
import scala.collection.mutable
import scala.collection.mutable.ListBuffer
import scala.collection.parallel.ParIterable
import scala.util.{Failure, Random, Success, Try}


object ParConstant {
  val groupSizeForParallelRun = 1500
  val parallelizationThreshold = 20000
  val parallelizationLevel = 30
}

object LaneUpdater {
  lazy val roadLinkChangeClient: RoadLinkChangeClient = new RoadLinkChangeClient
  lazy val roadLinkClient: RoadLinkClient = new RoadLinkClient(Digiroad2Properties.vvhRestApiEndPoint)
  lazy val roadLinkService: RoadLinkService = new RoadLinkService(roadLinkClient, new DummyEventBus, new DummySerializer)
  lazy val viiteClient: SearchViiteClient = new SearchViiteClient(Digiroad2Properties.viiteRestApiEndPoint, HttpClientBuilder.create().build())
  lazy val roadAddressService: RoadAddressService = new RoadAddressService(viiteClient)
  lazy val laneService: LaneService = new LaneService(roadLinkService, new DummyEventBus, roadAddressService)
  lazy val laneWorkListService: LaneWorkListService = new LaneWorkListService()
  lazy val autoProcessedLanesWorkListService: AutoProcessedLanesWorkListService = new AutoProcessedLanesWorkListService
  private val logger = LoggerFactory.getLogger(getClass)
  lazy val laneFiller: LaneFiller = new LaneFiller
  private var changes: Seq[ReportedChange] = Seq()
  var groupSizeForParallelRun = ParConstant.groupSizeForParallelRun
  var parallelizationThreshold = ParConstant.parallelizationThreshold
  var maximumParallelismLevel = ParConstant.parallelizationLevel
  
  def withDynTransaction[T](f: => T): T = PostGISDatabase.withDynTransaction(f)
  case class RoadLinkChangeWithResults(roadLinkChange: RoadLinkChange, changeSet: ChangeSet, lanesOnAdjustedLink: Seq[PersistedLane])

  //Returns random negative Long value for lanes to use as id before creation
  //Used for split lanes, so that final result can be adjusted in method fuseLanesOnMergedRoadLink
  def getPseudoId: Long = {
    val randomGen = new Random()
    -Math.abs(randomGen.nextLong)
  }

  def logChangeSetSizes(changeSet: ChangeSet, header:String = ""): Unit = {
    logger.info(s"${header} adjustedMValues size: ${changeSet.adjustedMValues.size}")
    logger.info(s"${header} adjustedSideCodes size: ${changeSet.adjustedSideCodes.size}")
    logger.info(s"${header} positionAdjustments size: ${changeSet.positionAdjustments.size}")
    logger.info(s"${header} expiredLaneIds size: ${changeSet.expiredLaneIds.size}")
    logger.info(s"${header} generatedPersistedLanes size: ${changeSet.generatedPersistedLanes.size}")
    logger.info(s"${header} splitLanes size: ${changeSet.splitLanes.size}")

    changeSet.adjustedMValues.groupBy(_.laneId).filter(_._2.size >= 2).foreach(a1 => {
      logger.error(s"${header} More than one M-Value adjustment for asset ids=${a1._2.sortBy(_.linkId).map(a => s"${a.laneId}/${a.linkId} start measure: ${a.startMeasure} end measure: ${a.endMeasure}").mkString(", ")}")
    })

    changeSet.adjustedSideCodes.groupBy(_.laneId).filter(_._2.size >= 2).foreach(a1 => {
      logger.error(s"${header} More than one sideCode change for asset/sidecode ids=${a1._2.map(a => s"${a.laneId}/${a.sideCode}").mkString(", ")}")
    })

    changeSet.positionAdjustments.groupBy(_.laneId).filter(_._2.size >= 2).foreach(a1 => {
      logger.error(s"${header} More than one position adjustments for asset ids=${a1._2.sortBy(_.linkId).map(a => s"${a.laneId}/${a.linkId} start measure: ${a.startMeasure} end measure: ${a.endMeasure}").mkString(", ")}")
    })
  }

  def fuseLaneSections(replacementResults: Seq[RoadLinkChangeWithResults]): (Seq[PersistedLane], ChangeSet) = {
    val (newLinkIds: Seq[String], changeSetMerged: ChangeSet, lanesOnNewLinks: Seq[PersistedLane]) =   LogUtils.time(logger, s"extractNeededValues ") {extractNeededValues(replacementResults)}
    val lanesGroupedByNewLinkId = LogUtils.time(logger, s"groupBy linkid ") {lanesOnNewLinks.groupBy(_.linkId)}
    val initialChangeSet = changeSetMerged
    val linksCount = lanesGroupedByNewLinkId.size
    logChangeSetSizes(initialChangeSet,"situation before fuse and after projecting")
    val (lanesAfterFuse: Seq[PersistedLane], changeSet: ChangeSet) = linksCount match {
      case a if a >= parallelizationThreshold => parallelFusing(lanesGroupedByNewLinkId,initialChangeSet)
      case _ => fusingLoop(newLinkIds, initialChangeSet,lanesGroupedByNewLinkId)
    }
    logChangeSetSizes(changeSet,"situation after fuse")
    (lanesAfterFuse, changeSet)
  }

  private def extractNeededValues(replacementResults: Seq[RoadLinkChangeWithResults]): (ListBuffer[String], ChangeSet, ListBuffer[PersistedLane]) = {
    val newLinkIds = new ListBuffer[String]()
    val lanesOnNewLinks = new ListBuffer[PersistedLane]()

    val adjustedMValues = new ListBuffer[MValueAdjustment]
    val adjustedSideCodes = new ListBuffer[SideCodeAdjustment]
    val positionAdjustments = new ListBuffer[LanePositionAdjustment]
    val expiredLaneIds = new ListBuffer[Long]
    val generatedPersistedLanes = new ListBuffer[PersistedLane]
    val splitLanes = new ListBuffer[LaneSplit]

    for (r <- replacementResults) {
      newLinkIds.appendAll(r.roadLinkChange.newLinks.map(_.linkId))
      lanesOnNewLinks.appendAll(r.lanesOnAdjustedLink)
      adjustedMValues.appendAll(r.changeSet.adjustedMValues)
      adjustedSideCodes.appendAll(r.changeSet.adjustedSideCodes.toList)
      positionAdjustments.appendAll(r.changeSet.positionAdjustments.toList)
      expiredLaneIds.appendAll(r.changeSet.expiredLaneIds.toList)
      generatedPersistedLanes.appendAll(r.changeSet.generatedPersistedLanes.toList)
      splitLanes.appendAll(r.changeSet.splitLanes.toList)
    }

    val changeSet = createChangeSet(
      adjustedMValues, adjustedSideCodes,
      positionAdjustments, expiredLaneIds,
      generatedPersistedLanes, splitLanes)

    (newLinkIds, changeSet, lanesOnNewLinks)
  }
  private def createChangeSet(adjustedMValues: ListBuffer[MValueAdjustment], adjustedSideCodes: ListBuffer[SideCodeAdjustment],
                              positionAdjustments: ListBuffer[LanePositionAdjustment], expiredLaneIds: ListBuffer[Long],
                              generatedPersistedLanes: ListBuffer[PersistedLane], splitLanes: ListBuffer[LaneSplit]): ChangeSet = {
    val merged = LogUtils.time(logger, s"merging split lanes") {splitLanes.distinct.groupBy(_.originalLane.id).map(
      a => LaneSplit(originalLane = a._2.head.originalLane, lanesToCreate = a._2.flatMap(_.lanesToCreate).distinct)
    ).toList}

    ChangeSet(
      adjustedMValues = adjustedMValues.distinct,
      adjustedSideCodes = adjustedSideCodes.distinct,
      positionAdjustments = positionAdjustments.distinct,
      expiredLaneIds = expiredLaneIds.toSet,
      generatedPersistedLanes = generatedPersistedLanes.distinct,
      splitLanes = merged
    )
  }
  private def fusingLoop(newLinkIds: Seq[String], initialChangeSet: ChangeSet, lanesGroupedByNewLinkId: Map[String, Seq[PersistedLane]]) = {
    logger.info(s"Start fuse loop")
    var percentageProcessed = 0

    val (lanesAfterFuse, changeSet) = newLinkIds.zipWithIndex.foldLeft(Seq.empty[PersistedLane], initialChangeSet) { case (accumulatedAdjustments, (linkId, index)) =>
      percentageProcessed = LogUtils.logArrayProgress(logger, "Fusing lane sections", newLinkIds.size, index, percentageProcessed)
      val (existingAssets, changedSet) = accumulatedAdjustments
      val assetsOnRoadLink = lanesGroupedByNewLinkId.getOrElse(linkId, Nil)
      val (adjustedAssets, assetAdjustments) = fuseLanesOnMergedRoadLink(assetsOnRoadLink, changedSet)
      ((existingAssets ++ adjustedAssets).distinct, assetAdjustments)
    }
    logger.info(s"End fuse loop")
    (lanesAfterFuse, changeSet)
  }

  private def parallelFusing(lanesGroupedByNewLinkId: Map[String, Seq[PersistedLane]], initialChangeSet: ChangeSet): (ListBuffer[PersistedLane], ChangeSet) = {
    logger.info(s"Start parallel fuse")
    val grouped = lanesGroupedByNewLinkId.grouped(groupSizeForParallelRun).toList.par
    val (totalTasks: Int, level: Int) = setParallelismLevel(grouped.size)
    val operated =  new Parallel().operation(grouped, level) { tasks =>
      tasks.map { al =>
        LogUtils.time(logger, s"Fusing task with items count ${al.size} ") {
          val ids = al.flatMap(_._2.map(_.id)).toSet
          val links = al.keys.toSet
          val lane = al.flatMap(_._2).toSeq
          val excludeUnneededChangSetItems = ChangeSet(
            adjustedMValues = initialChangeSet.adjustedMValues.filter(a => links.contains(a.linkId)),
            adjustedSideCodes = initialChangeSet.adjustedSideCodes.filter(a => ids.contains(a.laneId)),
            positionAdjustments = initialChangeSet.positionAdjustments.filter(a => ids.contains(a.laneId)),
            expiredLaneIds = initialChangeSet.expiredLaneIds.intersect(ids),
            splitLanes = initialChangeSet.splitLanes.map(a => {
              val correctLanes = a.lanesToCreate.filter(a => ids.contains(a.id))
              if (correctLanes.nonEmpty) {
                Some(LaneSplit(originalLane = a.originalLane, lanesToCreate = correctLanes))
              } else None
            }).filter(_.nonEmpty).map(_.get)
          )
          fuseLanesOnMergedRoadLink(lane, excludeUnneededChangSetItems)
        }
      }
    }

    val fused = new ListBuffer[PersistedLane]()
    val adjustedMValues = new ListBuffer[MValueAdjustment]
    val adjustedSideCodes = new ListBuffer[SideCodeAdjustment]
    val positionAdjustments = new ListBuffer[LanePositionAdjustment]
    val expiredLaneIds = new ListBuffer[Long]
    val generatedPersistedLanes = new ListBuffer[PersistedLane]
    val splitLanes = new ListBuffer[LaneSplit]
    
    LogUtils.time(logger, s"Extracting fused asset ") {
      for (t <-operated) {
        fused.appendAll(t._1);
        
        adjustedMValues.appendAll(t._2.adjustedMValues)
        adjustedSideCodes.appendAll(t._2.adjustedSideCodes.toList)
        positionAdjustments.appendAll(t._2.positionAdjustments.toList)
        expiredLaneIds.appendAll(t._2.expiredLaneIds.toList)
        generatedPersistedLanes.appendAll(t._2.generatedPersistedLanes.toList)
        splitLanes.appendAll(t._2.splitLanes.toList)
      }
    }
    val merged = createChangeSet(
      adjustedMValues, adjustedSideCodes,
      positionAdjustments,
      expiredLaneIds ++ initialChangeSet.expiredLaneIds,
      generatedPersistedLanes ++ initialChangeSet.generatedPersistedLanes,
      splitLanes ++ initialChangeSet.splitLanes.filter(_.lanesToCreate.isEmpty)
    )
    logger.info(s"End parallel fuse")
    (fused.distinct,merged)
  }

  private def setParallelismLevel(numberOfSets:Int) = {
    val totalTasks = numberOfSets
    val level = if (totalTasks < maximumParallelismLevel) totalTasks else maximumParallelismLevel
    logger.info(s"Asset groups: $totalTasks, parallelism level used: $level")
    (totalTasks, level)
  }
  def fuseLanesOnMergedRoadLink(lanesOnRoadLink: Seq[PersistedLane], changeSet: ChangeSet): (Seq[PersistedLane], ChangeSet) = {

    def equalAttributes(lane: PersistedLane, targetLane: PersistedLane): Boolean = {
      if(LaneNumber.isMainLane(lane.laneCode)) {
        LaneNumber.isMainLane(targetLane.laneCode)
      } else lane.attributes.equals(targetLane.attributes)
    }
    def partsAreContinues(origin: PersistedLane, sl: PersistedLane) = Math.abs(sl.startMeasure - origin.endMeasure) < 0.1
    
    val sortedList = lanesOnRoadLink.sortBy(_.startMeasure)

    if (lanesOnRoadLink.nonEmpty) {
      val origin = sortedList.head
      val target = sortedList.tail.find(sl =>
        (partsAreContinues(origin, sl) || (LaneNumber.isMainLane(origin.laneCode) && LaneNumber.isMainLane(sl.laneCode)))
        && equalAttributes(origin, sl) && sl.sideCode == origin.sideCode)
      if (target.nonEmpty) {
        // pick id if it already has one regardless of which one is newer
        val toBeFused = Seq(origin, target.get).sortWith(laneFiller.modifiedSort)
        val propertiesToUse = if(LaneNumber.isMainLane(origin.laneCode)) {
          getLatestStartDatePropertiesForFusedLanes(toBeFused)
        } else origin.attributes
        val newId = toBeFused.find(_.id != 0).map(_.id).getOrElse(0L)

        val modified = toBeFused.head.copy(id = newId, startMeasure = origin.startMeasure, endMeasure = target.get.endMeasure, attributes = propertiesToUse)
        val expiredId = Set(origin.id, target.get.id) -- Set(newId, 0L) // never attempt to expire id zero


        val positionAdjustment = changeSet.positionAdjustments.find(a => a.laneId == modified.id) match {
          case Some(adjustment) => Seq(adjustment.copy(startMeasure = modified.startMeasure, endMeasure = modified.endMeasure,
            sideCode = SideCode.apply(modified.sideCode), attributesToUpdate = Some(propertiesToUse)))
          case None if modified.id < 0 => Seq()
          case _ => Seq(LanePositionAdjustment(modified.id, modified.linkId, modified.startMeasure, modified.endMeasure,
            SideCode.apply(modified.sideCode), attributesToUpdate = Some(propertiesToUse)))
        }

        val splitLanesWithAdjusted = changeSet.splitLanes.map(laneSplit => {
          val lanesToCreateWithAdjusted = laneSplit.lanesToCreate.flatMap(laneToCreate => {
            laneToCreate.id match {
              case id if id == newId => Some(modified)
              case id if id == expiredId.headOption.getOrElse(0) => None
              case _ => Some(laneToCreate)
            }
          })
          laneSplit.copy(lanesToCreate = lanesToCreateWithAdjusted)
        })
        // Replace origin and target with this new item in the list and recursively call itself again
        val filteredList = Seq(modified) ++ sortedList.tail.filterNot(sl => Set(origin, target.get).contains(sl))
        // Filter out pseudo IDs
        val realIdsToExpire = expiredId.filter(id => id > 0)
        val expiredIdsAfterFuse = changeSet.expiredLaneIds ++ realIdsToExpire
        val positionAdjustmentsAfterFuse = changeSet.positionAdjustments.filter(a => a.laneId > 0 && a.laneId != modified.id &&
          !changeSet.expiredLaneIds.contains(a.laneId) && !realIdsToExpire.contains(a.laneId)) ++ positionAdjustment

        val changeSetWithFused = changeSet.copy(expiredLaneIds = expiredIdsAfterFuse,
          positionAdjustments = positionAdjustmentsAfterFuse, splitLanes = splitLanesWithAdjusted)
        fuseLanesOnMergedRoadLink(filteredList,changeSetWithFused)
      } else {
        val fused = fuseLanesOnMergedRoadLink(sortedList.tail, changeSet)
        (Seq(origin) ++ fused._1, fused._2)
      }
    } else {
      (lanesOnRoadLink, changeSet)
    }
  }

  def updateSamuutusChangeSet(changeSet: ChangeSet, roadLinkChanges: Seq[RoadLinkChange]): Seq[ChangedAsset] = {

    def expireLanes(laneIdsToExpire: Set[Long]): Seq[ChangedAsset] = {
      val persistedLanesToExpire = LogUtils.time(logger, s"Fetch ${laneIdsToExpire.size} lanes for expiring and report") {
        laneService.getPersistedLanesByIds(laneIdsToExpire, newTransaction = false)
      }
      val lanesToExpireWithNewIds = persistedLanesToExpire.map(lane => OldLaneWithNewId(lane, None))
      LogUtils.time(logger, s"Move ${laneIdsToExpire.size} expired lanes to history") {
        laneService.moveToHistoryBatch(lanesToExpireWithNewIds, AutoGeneratedUsername.generatedInUpdate)
      }
      persistedLanesToExpire.map(laneToExpire => {
        reportLaneChanges(Some(laneToExpire), Seq(), Deletion, roadLinkChanges)
      }).filter(_.nonEmpty).map(_.get)
    }

    def saveLanePositionAdjustments(positionAdjustments: Seq[LanePositionAdjustment]): Seq[ChangedAsset] = {
      val toAdjustLanes = LogUtils.time(logger, s"Fetch ${positionAdjustments.size} lanes for adjusting and report") {
        laneService.getPersistedLanesByIds(positionAdjustments.map(_.laneId).toSet, newTransaction = false)
      }

      val oldLanesAndLanesToCreate = positionAdjustments.map { adjustment =>
        val oldLane = toAdjustLanes.find(_.id == adjustment.laneId)
        // If adjustment has new attributes to update, use them
        // Used for updating fused main lane start dates
        val attributesToUse = adjustment.attributesToUpdate match {
          case Some(attributes) => attributes
          case None => oldLane.get.attributes
        }
        val laneToCreate = oldLane.get.copy(id = 0, linkId = adjustment.linkId, startMeasure = adjustment.startMeasure,
          endMeasure = adjustment.endMeasure, sideCode = adjustment.sideCode.value, attributes = attributesToUse)

        (oldLane.get, laneToCreate)
      }

      val newIds = LogUtils.time(logger, "Create adjusted lanes"){
        laneService.createMultipleLanes(oldLanesAndLanesToCreate.map(_._2), AutoGeneratedUsername.generatedInUpdate).map(_.id)
      }
      val oldLanesWithNewIdAndLaneToCreate = oldLanesAndLanesToCreate.zip(newIds).map {
        case ((oldLane, laneToCreate), newId) =>
          (OldLaneWithNewId(oldLane, Some(newId)), laneToCreate.copy(id = newId))
      }

      val oldLanesToHistory = oldLanesWithNewIdAndLaneToCreate.map(_._1)
      LogUtils.time(logger, s"Move ${oldLanesToHistory.size} adjusted lanes to history") {
        laneService.moveToHistoryBatch(oldLanesToHistory, AutoGeneratedUsername.generatedInUpdate)
      }

      oldLanesWithNewIdAndLaneToCreate.map(oldAndNewLane => {
        val oldLane = oldAndNewLane._1.lane
        val newLane = oldAndNewLane._2
        reportLaneChanges(Some(oldLane), Seq(newLane), Replaced, roadLinkChanges)
      }).filter(_.nonEmpty).map(_.get)
    }

    def saveDividedLanes(laneSplits: Seq[LaneSplit]): Seq[ChangedAsset] = {
      val lanesToCreate = laneSplits.flatMap(_.lanesToCreate).toSet

      logger.info("Creating " + lanesToCreate.size + " new lanes due to split on link ids: " + lanesToCreate.map(_.linkId).mkString(", "))
      //TODO If too slow, refactor code to create all split lanes in a single query
      val laneSplitsWithCreatedIds = LogUtils.time(logger, s"Create ${laneSplits.flatMap(_.lanesToCreate).size} lanes due to split") {
        laneSplits.map(split => {
          val createdLanes = laneService.createMultipleLanes(split.lanesToCreate, split.originalLane.createdBy.get)
          LaneSplit(createdLanes, split.originalLane)
        })
      }

      val (splitsWithNewLanes, splitsWithNoNewLanes) = laneSplitsWithCreatedIds.partition(_.lanesToCreate.nonEmpty)
      // Each old lane must have history row referencing to each new lane created from it
      val oldLanesWithNewIds = splitsWithNewLanes.flatMap(split => {
        split.lanesToCreate.map(newLane => {
          OldLaneWithNewId(split.originalLane, Some(newLane.id))
        })
      })
      val oldLanesWithNoNewIds = splitsWithNoNewLanes.map(split => {
        OldLaneWithNewId(split.originalLane, None)
      })

      val oldLanesToHistory = oldLanesWithNewIds ++ oldLanesWithNoNewIds
      LogUtils.time(logger, s"Move ${oldLanesToHistory.size} split lanes to history") {
        laneService.moveToHistoryBatch(oldLanesToHistory,  AutoGeneratedUsername.generatedInUpdate)
      }

      laneSplitsWithCreatedIds.map(split => {
        reportLaneChanges(Some(split.originalLane), split.lanesToCreate, Divided, roadLinkChanges)
      }).filter(_.nonEmpty).map(_.get)
    }


    def saveGeneratedLanes(lanesToGenerate: Seq[PersistedLane]): Seq[ChangedAsset] = {
      val createdLanes = LogUtils.time(logger, s"Create ${lanesToGenerate.size} generated lanes") {
        laneService.createMultipleLanes(lanesToGenerate, AutoGeneratedUsername.generatedInUpdate)
      }
      createdLanes.map(createdLane => {
        reportLaneChanges(None, Seq(createdLane), Creation, roadLinkChanges)
      }).filter(_.nonEmpty).map(_.get)
    }

    logChangeSetSizes(changeSet)

    // Expire lanes which have been marked to be expired
    val expiredChangedLanes = if(changeSet.expiredLaneIds.nonEmpty) {
      logger.info("Expiring " + changeSet.expiredLaneIds.size + "ids: " + changeSet.expiredLaneIds.mkString(", "))
      expireLanes(changeSet.expiredLaneIds)
    } else Seq()

    // Save generated lanes
    val generatedChangedLanes = if(changeSet.generatedPersistedLanes.nonEmpty) {
      logger.info(s"${changeSet.generatedPersistedLanes.size} lanes to be created for ${changeSet.generatedPersistedLanes.map(_.linkId).toSet.size} links")
      saveGeneratedLanes(changeSet.generatedPersistedLanes)
    } else Seq()

    // Save samuutus sideCode and M-value adjustments
    val adjustedPositionChangedLanes = if (changeSet.positionAdjustments.nonEmpty) {
      logger.info(s"Saving SideCode/M-Value adjustments for ${changeSet.positionAdjustments.size} lanes")
      saveLanePositionAdjustments(changeSet.positionAdjustments)
    } else Seq()

    // Create new divide lanes, and expire old lanes due to road link splits
    val splitChangedLanes = if (changeSet.splitLanes.nonEmpty) {
      logger.info(s"Saving divides for ${changeSet.splitLanes.size} lanes")
      saveDividedLanes(changeSet.splitLanes)
    } else Seq()

    expiredChangedLanes ++ generatedChangedLanes ++ adjustedPositionChangedLanes ++ splitChangedLanes
  }



  def updateLanes(): Unit = {
    val lastSuccess = PostGISDatabase.withDynSession( Queries.getLatestSuccessfulSamuutus(Lanes.typeId) )
    val changeSets = roadLinkChangeClient.getRoadLinkChanges(lastSuccess)

    changeSets.foreach( roadLinkChangeSet => {
      try {
        PostGISDatabase.withDynTransaction {
          changes = updateByRoadLinks(roadLinkChangeSet)
          ValidateSamuutus.validate(Lanes.typeId, roadLinkChangeSet)
          generateAndSaveReport(roadLinkChangeSet.targetDate)
        }
      } catch {
        case e: SamuutusFailed =>
          generateAndSaveReport(roadLinkChangeSet.targetDate)
          throw e
      }
    })
  }

  /**
   * Filters processed RoadLinkChanges with the following principles:
   *
   * Remove new links that already have lanes, so that duplicate lanes will not be created.
   *
   * @param changes
   * @return filtered changes
   */
  def filterChanges(changes: Seq[RoadLinkChange]): Seq[RoadLinkChange] = {
    val newLinkIds = changes.flatMap(_.newLinks.map(_.linkId))
    val linkIdsWithExistingLanes = laneService.fetchAllLanesByLinkIds(newLinkIds, newTransaction = false).map(_.linkId)
    if (linkIdsWithExistingLanes.nonEmpty) logger.info(s"found already created lanes on new links ${linkIdsWithExistingLanes}")
    changes.filterNot(c => c.changeType == Add && linkIdsWithExistingLanes.contains(c.newLinks.head.linkId))
  }

  private def updateByRoadLinks(roadLinkChangeSet: RoadLinkChangeSet) = {
    logger.info(s"Started processing change set ${roadLinkChangeSet.key}")
    val allRoadLinkChanges = roadLinkChangeSet.changes
    val filteredRoadLinkChanges = LogUtils.time(logger, "filterChanges ") {filterChanges(allRoadLinkChanges)}

    logger.info("Starting to process traffic direction changes")
    LogUtils.time(logger, "Update Lane Work List with possible traffic direction changes") {
      updateTrafficDirectionChangesLaneWorkList(filteredRoadLinkChanges)
    }
    
    
    val linkIdsOnLaneWorkList = laneWorkListService.getLaneWorkList(false).map(_.linkId)
    val linkIdsOnAutoProcessedLanesWorkList = autoProcessedLanesWorkListService.getAutoProcessedLanesWorkList(false).map(_.linkId)
    val (workListChanges, roadLinkChanges) = filteredRoadLinkChanges.partition(change => isOldLinkOnLaneWorkLists(change,linkIdsOnLaneWorkList, linkIdsOnAutoProcessedLanesWorkList))
    logger.info("Starting to process changes")
    val changeSet = LogUtils.time(logger, s"Process ${workListChanges.size} workListChanges and ${roadLinkChanges.size} roadLinkChanges") {
      handleChanges(roadLinkChanges, workListChanges)
    }
    logger.info("Starting to save lane samuutus results")
    val changedLanes = LogUtils.time(logger, "Saving Lane samuutus results") {
      updateSamuutusChangeSet(changeSet, filteredRoadLinkChanges)
    }
    changedLanes
  }
  /**
    * Each report saving array [[LaneUpdater.changes]] is erased.
    */
  def generateAndSaveReport(processedTo: DateTime): Unit = {
    val (reportBody, contentRowCount) = ChangeReporter.generateCSV(ChangeReport(Lanes.typeId, changes))
    ChangeReporter.saveReportToS3(Lanes.label, processedTo, reportBody, contentRowCount)
    val (reportBodyWithGeom, _) = ChangeReporter.generateCSV(ChangeReport(Lanes.typeId, changes), withGeometry = true)
    ChangeReporter.saveReportToS3(Lanes.label, processedTo, reportBodyWithGeom, contentRowCount, hasGeometry = true)
    changes = Seq()
  }

  def updateTrafficDirectionChangesLaneWorkList(roadLinkChanges: Seq[RoadLinkChange]): Unit = {
    val oldLinkIds = roadLinkChanges.flatMap(_.oldLink).map(_.linkId)
    val (mainLanesOnOldLinks, additionalLanesOnOldLinks) = laneService.fetchAllLanesByLinkIds(oldLinkIds, newTransaction = false).partition(lane => LaneNumber.isMainLane(lane.laneCode))
    val changesFiltered = roadLinkChanges.filterNot(change => change.changeType == RoadLinkChangeType.Add ||
      change.changeType == RoadLinkChangeType.Remove)
    changesFiltered.foreach(change => {
      if (isRealTrafficDirectionChange(change)) {
        change.newLinks.foreach(newLink => {
          val oldLink = change.oldLink.get
          val mainLanesOnLink = mainLanesOnOldLinks.filter(_.linkId == oldLink.linkId)
          val additionalLanesOnLink = additionalLanesOnOldLinks.filter(_.linkId == oldLink.linkId)
          val oldTD = oldLink.trafficDirection
          val newTD = newLink.trafficDirection
          val mainLanesStartDates = mainLanesOnLink.flatMap(lane => laneService.getPropertyValue(lane, "start_date")).map(_.value).asInstanceOf[Seq[String]]
          // If Traffic direction has changed on replacing link, link needs to be inserted to Automatically processed lanes work list
          // because main lanes on old link will be expired and new ones with no connecting history will be generated for replacing link in samuutus
          val autoProcessedLanesWorkListItem = AutoProcessedLanesWorkListItem(0, newLink.linkId, "traffic_direction", oldTD.value, newTD.value, mainLanesStartDates,
            DateTime.now(), AutoGeneratedUsername.generatedInUpdate)
          autoProcessedLanesWorkListService.insertToAutoProcessedLanesWorkList(autoProcessedLanesWorkListItem, newTransaction = false)
          // If old link has additional lanes, insert link also to Lane work list for later manual processing, additional
          // lanes on links with changed traffic direction are not processed during samuutus
          if(additionalLanesOnLink.nonEmpty) {
            val laneWorkListItem = LaneWorkListItem(0, oldLink.linkId, "traffic_direction", oldTD.value, newTD.value,
              DateTime.now(), AutoGeneratedUsername.generatedInUpdate)
            laneWorkListService.insertToLaneWorkList(laneWorkListItem, newTransaction = false)
          }
        })
      }
    })
  }

  // If lanes from old roadLink are currently on Lane work list or Automatically processed lanes work list
  // then only process the main lanes on changed link
  def isOldLinkOnLaneWorkLists(change: RoadLinkChange,linkIdsOnLaneWorkList: Seq[String],linkIdsOnAutoProcessedLanesWorkList: Seq[String]): Boolean = {
    change.oldLink match {
      case Some(oldLink) =>
        linkIdsOnLaneWorkList.contains(oldLink.linkId) || linkIdsOnAutoProcessedLanesWorkList.contains(oldLink.linkId)
      case None => false
    }
  }

  def isRealTrafficDirectionChange(change: RoadLinkChange): Boolean = {
    change.newLinks.exists(newLink => {
      val oldOriginalTrafficDirection = change.oldLink.get.trafficDirection
      val newOriginalTrafficDirection = newLink.trafficDirection
      val replaceInfo = change.replaceInfo.find(_.newLinkId.getOrElse(None) == newLink.linkId).getOrElse(throw new NoSuchElementException(s"Replace info for link ${newLink.linkId} not found from change ${change}"))
      val isDigitizationChange = replaceInfo.digitizationChange
      val overWrittenTdValueOnNewLink = TrafficDirectionDao.getExistingValue(newLink.linkId)

      if (overWrittenTdValueOnNewLink.nonEmpty) false
      else {
        if (isDigitizationChange) oldOriginalTrafficDirection != TrafficDirection.switch(newOriginalTrafficDirection)
        else oldOriginalTrafficDirection != newOriginalTrafficDirection
      }
    })
  }

  def handleTrafficDirectionChange(workListChanges: Seq[RoadLinkChange], workListMainLanes: Seq[PersistedLane],addedRoadLinks: Seq[RoadLink]): (ChangeSet, Seq[PersistedLane]) = {
    val laneIdsToExpire = workListMainLanes.map(_.id).toSet
    val createdMainLanes = workListChanges.flatMap(change => {
      val newLinkIds = change.newLinks.map(_.linkId)
      val neededLinks = addedRoadLinks.filter(a=> newLinkIds.contains(a.linkId))
      val createdMainLanes = MainLanePopulationProcess.createMainLanesForRoadLinks(neededLinks, saveResult = false)
      createdMainLanes
    })

    (ChangeSet(expiredLaneIds = laneIdsToExpire, generatedPersistedLanes = createdMainLanes), createdMainLanes)
  }

  def reportLaneChanges(oldLane: Option[PersistedLane], newLanes: Seq[PersistedLane], changeType: ChangeType, roadLinkChanges: Seq[RoadLinkChange]): Option[ChangedAsset] = {
    val linkId = if (oldLane.nonEmpty) oldLane.get.linkId else newLanes.head.linkId
    val assetId = if (oldLane.nonEmpty) oldLane.get.id else 0

    val relevantRoadLinkChangeOpt = roadLinkChanges.find(change => {
      val roadLinkChangeOldLinkId = change.oldLink match {
        case Some(oldLink) => Some(oldLink.linkId)
        case None => None
      }
      val laneOldLinkId = oldLane match {
        case Some(lane) => Some(lane.linkId)
        case None => None
      }
      val roadLinkChangeNewLinkIds = change.newLinks.map(_.linkId).sorted
      val lanesNewLinkIds = newLanes.map(_.linkId).sorted

      ((roadLinkChangeOldLinkId.nonEmpty && laneOldLinkId.nonEmpty) && roadLinkChangeOldLinkId == laneOldLinkId) || roadLinkChangeNewLinkIds == lanesNewLinkIds
    })
    
   relevantRoadLinkChangeOpt match {
      case Some(relevantRoadLinkChange) => 
        val before = oldLane match {
          case Some(ol) =>
            val values = compactJson(JObject(ol.attributes.flatMap(_.toJson).toList))
            val linkGeometry = relevantRoadLinkChange.oldLink.get.geometry
            val linkInfo = Some(LinkInfo(relevantRoadLinkChange.oldLink.get.lifeCycleStatus))
            val laneGeometry = GeometryUtils.truncateGeometry3D(linkGeometry, ol.startMeasure, ol.endMeasure)
            val linearReference = LinearReferenceForReport(ol.linkId, ol.startMeasure, Some(ol.endMeasure), Some(ol.sideCode), None, None, ol.endMeasure - ol.startMeasure)
            Some(Asset(ol.id, values, Some(ol.municipalityCode.toInt), Some(laneGeometry), Some(linearReference), linkInfo))
          case None => None
        }
        val after = newLanes.map(nl => {
          val maybeLink = relevantRoadLinkChange.newLinks.find(_.linkId == nl.linkId)
          val linkInfo = if (maybeLink.nonEmpty) Some(LinkInfo(maybeLink.get.lifeCycleStatus)) else None
          val values = compactJson(JObject(nl.attributes.flatMap(_.toJson).toList))
          val linkGeometry = if (maybeLink.nonEmpty) maybeLink.get.geometry else Seq.empty[Point]
          val laneGeometry = GeometryUtils.truncateGeometry3D(linkGeometry, nl.startMeasure, nl.endMeasure)
          val linearReference = LinearReferenceForReport(nl.linkId, nl.startMeasure, Some(nl.endMeasure), Some(nl.sideCode), None, None, nl.endMeasure - nl.startMeasure)
          Asset(nl.id, values, Some(nl.municipalityCode.toInt), Some(laneGeometry), Some(linearReference), linkInfo)
        })
        Some(ChangedAsset(linkId, assetId, changeType, relevantRoadLinkChange.changeType, before, after))
      case None =>
        val oldLaneLink = if (oldLane.nonEmpty) oldLane.get.linkId else ""
        logger.error(s"Could not find relevant road link change. Lane old linkId: ${oldLaneLink} Lane new linkId: ${newLanes.map(_.linkId).toString()}")
        logger.error(s"Lanes where old lane : ${oldLane.toString} and new lane: ${newLanes.toString()}")
        None
    }
  }

  private def splitOldAndNewIds(roadLinkChanges: Seq[RoadLinkChange]): (ListBuffer[String], ListBuffer[String]) = {
   val (newLinkIds,oldLinkIds) = (new ListBuffer[String](),new ListBuffer[String]())
    for (r <- roadLinkChanges) {
      newLinkIds.appendAll(r.newLinks.map(_.linkId)); oldLinkIds.appendAll(r.oldLink.map(_.linkId))
    }
    (oldLinkIds,newLinkIds )
  }
  
  def handleChanges(roadLinkChanges: Seq[RoadLinkChange], workListChanges: Seq[RoadLinkChange] = Seq()): ChangeSet = {
    val (oldLinkIds, newLinkIds) =  LogUtils.time(logger, s"splitOldAndNewIds") {splitOldAndNewIds(roadLinkChanges)}
    val oldWorkListLinkIds = workListChanges.flatMap(_.oldLink).map(_.linkId)

    val newLinkIdsString = newLinkIds.toSet ++ workListChanges.flatMap(_.newLinks.map(_.linkId)).toSet
    logger.info(s"Start fetching lanes and links") 
    
    val newRoadLinks = roadLinkService.getExistingAndExpiredRoadLinksByLinkIds(newLinkIdsString, newTransaction = false)
    // when working on 1 million lanes it is better just fetch lanes multiple time
    val linkIdsWithExistingLane = laneService.fetchAllLanesByLinkIds(newLinkIds, newTransaction = false).map(_.linkId)
    val lanesOnOldRoadLinks = laneService.fetchAllLanesByLinkIds(oldLinkIds, newTransaction = false)
    val lanesOnWorkListLinks = laneService.fetchAllLanesByLinkIds(oldWorkListLinkIds, newTransaction = false)
    logger.info(s"End fetching lanes and links") 
    
    if (linkIdsWithExistingLane.nonEmpty) logger.info(s"found already created lanes on new links ${linkIdsWithExistingLane.mkString(", ")}")
    val filteredChanges = LogUtils.time(logger, s"filteredChanges") {
      roadLinkChanges.filterNot(c => c.changeType == Add && linkIdsWithExistingLane.contains(c.newLinks.head.linkId))
    }
    
    // Additional lanes can't be processed if link is on the lane work list, only handle main lanes on those links
    val workListMainLanes = lanesOnWorkListLinks.filter(lane => LaneNumber.isMainLane(lane.laneCode))
    val (trafficDirectionChangeSet, trafficDirectionCreatedMainLanes) =LogUtils.time(logger, s"handleTrafficDirectionChange ") {
      handleTrafficDirectionChange(workListChanges, workListMainLanes,newRoadLinks)
    }
    val lanesGroup = LogUtils.time(logger, s"groupByPropertyHashMap with ${lanesOnOldRoadLinks.size}") {
      IterableOperation.groupByPropertyHashMap(lanesOnOldRoadLinks, (elem: PersistedLane) => elem.linkId)
    }
    
    def operateChangeLoop(): Seq[RoadLinkChangeWithResults] = {
      var percentageProcessed = 0
      LogUtils.time(logger, s"Core samuutus handling for ${filteredChanges.size} changes") {
        filteredChanges.zipWithIndex.map(changeWithIndex => {
          val (change, index) = changeWithIndex
          percentageProcessed = LogUtils.logArrayProgress(logger, "Core samuutus handling", filteredChanges.size, index, percentageProcessed)
          operateChanges(newRoadLinks, lanesGroup, change)
        })
      }
    }
    logger.info(s"Start processing roadlink changes: ${filteredChanges.size}")
    val changeSetsAndAdjustedLanes: Seq[RoadLinkChangeWithResults] = filteredChanges.size match {
      case a if a >= parallelizationThreshold => parLoopChanges(newRoadLinks, filteredChanges, lanesGroup).toList
      case _ => operateChangeLoop()
    }
    logger.info(s"End processing roadlink changes")
    val linksPartOfReplacement = extractOnlyReplacementLinkIds(changeSetsAndAdjustedLanes)

    logger.info(s"Start fusing lanes")
    val (_, changeSetAfterFuse) = LogUtils.time(logger, s"Fusing lane sections"){
      fuseLaneSections(changeSetsAndAdjustedLanes)
    }
    logger.info(s"End fusing lanes")
    val finalChangeSet = LogUtils.time(logger, s"combineChangeSets ") {Seq(trafficDirectionChangeSet, changeSetAfterFuse).foldLeft(ChangeSet())(LaneFiller.combineChangeSets)}
    val removedSplit = LogUtils.time(logger, s"removeSplitWhichAreAlsoPartOfMerger ") { removeSplitWhichAreAlsoPartOfMerger(finalChangeSet,linksPartOfReplacement)}
    finalChangeSet.copy(splitLanes = removedSplit)
  }

  private def extractOnlyReplacementLinkIds(changeSetsAndAdjustedLanes: Seq[RoadLinkChangeWithResults]): Seq[String] = {
    val newLinkIds = new ListBuffer[String]()
    for (r <- changeSetsAndAdjustedLanes) {
      if(r.roadLinkChange.changeType == RoadLinkChangeType.Replace ) {
        newLinkIds.appendAll(r.roadLinkChange.newLinks.map(_.linkId))
      }
    }
    newLinkIds
  }
  private def parLoopChanges(newRoadLinks: Seq[RoadLink], filteredChanges: Seq[RoadLinkChange], lanesGroup: mutable.HashMap[String, Set[PersistedLane]]): ParIterable[RoadLinkChangeWithResults] = {
    val grouped = filteredChanges.grouped(groupSizeForParallelRun).toList.par
    val (totalTasks: Int, level: Int) = setParallelismLevel(grouped.size)
    LogUtils.time(logger, s"Core samuutus handling for ${filteredChanges.size} changes, multithreaded") {
      new Parallel().operation(grouped, level) { tasks =>
        tasks.map { al =>
          LogUtils.time(logger, s"Samuutus task with items count ${al.size} ") {
            al.map(operateChanges(newRoadLinks, lanesGroup, _))
          }
        }
      }.flatten
    }
  }
  private def operateChanges(newRoadLinks: Seq[RoadLink], lanesOnOldRoadLinks: mutable.HashMap[String, Set[PersistedLane]], change: RoadLinkChange) = {
    val relevantLinks = LogUtils.time(logger, s"Preparing operateChanges by filtering links") {
      val relevantLinksIds = change.newLinks.map(_.linkId) ++ change.oldLink.map(_.linkId)
      newRoadLinks.filter(a => relevantLinksIds.contains(a.linkId))
    }
    LogUtils.time(logger, s"Change type: ${change.changeType.value}, Operating changes") {
      change.changeType match {
        case RoadLinkChangeType.Add =>
          handleAddChange(change, relevantLinks)
        case RoadLinkChangeType.Remove =>
          handleRemoveChange(change, lanesOnOldRoadLinks)
        case RoadLinkChangeType.Replace =>
          handleReplaceChange(change, relevantLinks, lanesOnOldRoadLinks)
        case RoadLinkChangeType.Split =>
          handleSplitChange(change, relevantLinks, lanesOnOldRoadLinks)
      }
    }
  }
  private def handleAddChange(change: RoadLinkChange, relevantLinks: Seq[RoadLink]): RoadLinkChangeWithResults = {
    val newRoadLinkInfo = change.newLinks.headOption
      .getOrElse(throw new NoSuchElementException(s"Replacement change is missing new link info, old linkID: ${change.oldLink.get.linkId}"))
    val addedRoadLinkOption = relevantLinks.find(_.linkId == newRoadLinkInfo.linkId)
    addedRoadLinkOption match {
      case Some(roadLink) =>
        if (roadLink.linkType == TractorRoad) {
          RoadLinkChangeWithResults(change, ChangeSet(), Seq())
        } else {
          val createdMainLanes = MainLanePopulationProcess.createMainLanesForRoadLinks(Seq(roadLink), saveResult = false)
          RoadLinkChangeWithResults(change, ChangeSet(generatedPersistedLanes = createdMainLanes), createdMainLanes)
        }
      case None =>
        RoadLinkChangeWithResults(change, ChangeSet(), Seq())
    }
  }

  private def handleRemoveChange(change: RoadLinkChange, lanesOnOldRoadLinks:  mutable.HashMap[String, Set[PersistedLane]]): RoadLinkChangeWithResults = {
    val lanesToExpireOnRemovedLink = extractLanes(lanesOnOldRoadLinks, change.oldLink.get).map(_.id).toSet
    RoadLinkChangeWithResults(change, ChangeSet(expiredLaneIds = lanesToExpireOnRemovedLink), Seq())
  }

  private def handleReplaceChange(change: RoadLinkChange, relevantLinks: Seq[RoadLink], lanesOnOldRoadLinks:  mutable.HashMap[String, Set[PersistedLane]]): RoadLinkChangeWithResults = {
    val lanesOnReplacedLink = extractLanes(lanesOnOldRoadLinks, change.oldLink.get)
    val newRoadLinkInfo = change.newLinks.headOption
      .getOrElse(throw new NoSuchElementException(s"Replacement change is missing new link info, old linkID: ${change.oldLink.get.linkId}"))
    val newLinkId = newRoadLinkInfo.linkId
    val replacementRoadLinkOption = relevantLinks.find(_.linkId == newLinkId)
    replacementRoadLinkOption match {
      case Some(roadLink) =>
        if (roadLink.linkType == TractorRoad) {
          RoadLinkChangeWithResults(change, ChangeSet(expiredLaneIds = lanesOnReplacedLink.map(_.id).toSet), Seq())
        } else {
          val adjustmentsAndAdjustedLanes = fillReplacementLinksWithExistingLanes(lanesOnReplacedLink, change)
          val adjustments = adjustmentsAndAdjustedLanes.map(_._1)
          val adjustedLanes = adjustmentsAndAdjustedLanes.map(_._2)
          RoadLinkChangeWithResults(change, ChangeSet(positionAdjustments = adjustments), adjustedLanes)
        }
      case None =>
        RoadLinkChangeWithResults(change, ChangeSet(expiredLaneIds = lanesOnReplacedLink.map(_.id).toSet), Seq())
    }

  }

  private def handleSplitChange(change: RoadLinkChange, relevantLinks: Seq[RoadLink], lanesOnOldRoadLinks:  mutable.HashMap[String, Set[PersistedLane]]): RoadLinkChangeWithResults= {
    val oldRoadLink = change.oldLink.get
    val newSplitRoadLinks = relevantLinks.filter(link => change.newLinks.map(_.linkId).contains(link.linkId))
    val lanesOnSplitLink = extractLanes(lanesOnOldRoadLinks, oldRoadLink)
    val adjustmentsAndAdjustedLanes = fillSplitLinksWithExistingLanes(lanesOnSplitLink, newSplitRoadLinks, change)
    val adjustments = adjustmentsAndAdjustedLanes._1
    val adjustedLanes = adjustmentsAndAdjustedLanes._2
    RoadLinkChangeWithResults(change, ChangeSet(splitLanes = adjustments), adjustedLanes)
  }

  private def extractLanes(lanesOnOldRoadLinks: mutable.HashMap[String, Set[PersistedLane]], oldRoadLink: RoadLinkInfo) = {
    Try(lanesOnOldRoadLinks(oldRoadLink.linkId)) match {
      case Success(value) => value.toSeq
      case Failure(_) => Seq()
    }
  }
  private def removeSplitWhichAreAlsoPartOfMerger(finalChangeSet: ChangeSet, linksPartOfReplacement:Seq[String]) = {
    finalChangeSet.splitLanes.map(b => {
      b.copy(lanesToCreate = b.lanesToCreate.filterNot(c => linksPartOfReplacement.contains(c.linkId)))
    })
  }
  // In case main lane's parent lanes have different start dates, we want to inherit the latest date
  def getLatestStartDatePropertiesForFusedLanes(lanesToMerge: Seq[PersistedLane]): Seq[LaneProperty] = {
    val startDateStrings = lanesToMerge.flatMap(parentLane => laneService.getPropertyValue(parentLane, "start_date")).map(_.value).asInstanceOf[Seq[String]]
    val dateFormat = new SimpleDateFormat("d.M.yyyy")
    val startDates = startDateStrings.map(dateString => dateFormat.parse(dateString))
    val latestDate = startDates.max
    val latestDateString = dateFormat.format(latestDate)

    val lanePropertiesToUse = Seq(
      LaneProperty("lane_code", Seq(LanePropertyValue(LaneNumber.MainLane.oneDigitLaneCode))),
      LaneProperty("lane_type", Seq(LanePropertyValue(LaneType.Main.value))),
      LaneProperty("start_date", Seq(LanePropertyValue(latestDateString)))
    )

    lanePropertiesToUse
  }

  def calculateAdditionalLanePositionsOnSplitLinks(oldAdditionalLanes: Seq[PersistedLane], change: RoadLinkChange): Seq[LaneSplit] = {
    oldAdditionalLanes.map(originalAdditionalLane => {
      val replaceInfosAffectingLane = change.replaceInfo.filter(replaceInfo => {
        GeometryUtils.liesInBetweenExclusiveEnd(originalAdditionalLane.startMeasure, (replaceInfo.oldFromMValue.getOrElse(0.0), replaceInfo.oldToMValue.getOrElse(0.0))) ||
          GeometryUtils.liesInBetweenExclusiveStart(originalAdditionalLane.endMeasure, (replaceInfo.oldFromMValue.getOrElse(0.0), replaceInfo.oldToMValue.getOrElse(0.0)))
      })
      val lanesSplitFromOriginal = replaceInfosAffectingLane.map(replaceInfo => {
        val newId = replaceInfo.newLinkId.getOrElse("")
        val newRoadLinkLength = if (newId.nonEmpty) change.newLinks.find(_.linkId == newId).get.linkLength else 0
        val laneLinearReference = AssetLinearReference(originalAdditionalLane.id, originalAdditionalLane.startMeasure,
          originalAdditionalLane.endMeasure, originalAdditionalLane.sideCode)
        val newMValues = if (replaceInfo.newFromMValue.nonEmpty && replaceInfo.newToMValue.nonEmpty) (replaceInfo.newFromMValue.get, replaceInfo.newToMValue.get) else (0.0, 0.0)
        val projection = Projection(replaceInfo.oldFromMValue.getOrElse(0.0), replaceInfo.oldToMValue.getOrElse(0.0), newMValues._1, newMValues._2)
        val (newStartM, newEndM, newSideCode) = MValueCalculator.calculateNewMValues(laneLinearReference, projection, newRoadLinkLength, replaceInfo.digitizationChange)
        originalAdditionalLane.copy(id = getPseudoId ,startMeasure = newStartM, endMeasure = newEndM, linkId = newId, sideCode = newSideCode)
      }).filter(_.linkId.nonEmpty)
      LaneSplit(lanesSplitFromOriginal, originalAdditionalLane)
    })
  }

  def createSplitMainLanes(oldMainLanes: Seq[PersistedLane], splitChange: RoadLinkChange): Seq[LaneSplit] = {
    oldMainLanes.map(originalMainLane => {
      val replaceInfos = splitChange.replaceInfo
      val splitMainLanesToCreate = replaceInfos.map(replaceInfo => {
        val newId = replaceInfo.newLinkId.getOrElse("")
        val newRoadLinkLength = if (newId.nonEmpty) splitChange.newLinks.find(_.linkId == newId).get.linkLength else 0
        val newSideCode = if(replaceInfo.digitizationChange) switch(SideCode.apply(originalMainLane.sideCode)).value
        else originalMainLane.sideCode
        val splitLaneStartMeasure = 0.0
        val splitLaneEndMeasure = LaneUtils.roundMeasure(newRoadLinkLength)
        originalMainLane.copy(id = getPseudoId, linkId =replaceInfo.newLinkId.getOrElse(""), sideCode = newSideCode, startMeasure = splitLaneStartMeasure, endMeasure = splitLaneEndMeasure)
      }).filter(_.linkId.nonEmpty)
      LaneSplit(splitMainLanesToCreate, originalMainLane)
    })
  }

  def fillSplitLinksWithExistingLanes(lanesToUpdate: Seq[PersistedLane], newRoadLinks: Seq[RoadLink], change: RoadLinkChange): (Seq[LaneSplit], Seq[PersistedLane]) = {
    /**
      * Filter divided lanes to be created by linkType and finding replacing roadLink.
      * If RoadLink is missing, it means it's not handled by Digiroad because of its FeatureClass or ConstructionType
      * @param laneSplit LaneSplit object in which lanesToCreate are filtered from
      * @return LaneSplit object with lanes on incorrect links filtered out
      */
    def filterSplitLanes(laneSplit: LaneSplit): LaneSplit = {
      val lanesToCreateFiltered = laneSplit.lanesToCreate.filter(laneToCreate => {
        val newRoadLinkOption = newRoadLinks.find(_.linkId == laneToCreate.linkId)
        newRoadLinkOption match {
          case Some(roadLink) => roadLink.linkType != TractorRoad
          case None =>
            false
        }
      })
      laneSplit.copy(lanesToCreate = lanesToCreateFiltered)
    }

    val (mainLanesOnOldLink, additionalLanesOnOldLink) = lanesToUpdate.partition(lane => isMainLane(lane.laneCode))
    val mainLaneSplits = createSplitMainLanes(mainLanesOnOldLink, change)
    val additionalLaneSplits = calculateAdditionalLanePositionsOnSplitLinks(additionalLanesOnOldLink, change)
    val adjustments = (mainLaneSplits ++ additionalLaneSplits).map(filterSplitLanes)
    val splitLanes = adjustments.flatMap(_.lanesToCreate)
    (adjustments, splitLanes)
  }

  def fillReplacementLinksWithExistingLanes(lanesToUpdate: Seq[PersistedLane], change: RoadLinkChange): Seq[(LanePositionAdjustment, PersistedLane)] = {
    val newRoadLinks = change.newLinks
    newRoadLinks.flatMap(newRoadlink => {
      val replaceInfo = change.replaceInfo.find(_.newLinkId.get == newRoadlink.linkId).get
      val laneAdjustmentsOnLink = lanesToUpdate.map(lane => {
        val laneLinearReference = AssetLinearReference(lane.id, lane.startMeasure, lane.endMeasure, lane.sideCode)
        val projection = Projection(replaceInfo.oldFromMValue.getOrElse(0.0), replaceInfo.oldToMValue.getOrElse(0.0), replaceInfo.newFromMValue.get, replaceInfo.newToMValue.get)
        val (newStartM, newEndM, newSideCode) = if (LaneNumber.isMainLane(lane.laneCode)) {
          val newMainLaneSideCode = if (replaceInfo.digitizationChange) {
            SideCode.switch(SideCode.apply(lane.sideCode)).value
          } else lane.sideCode
          (0.0, MValueCalculator.roundMeasure(newRoadlink.linkLength), newMainLaneSideCode)
        } else {
          MValueCalculator.calculateNewMValues(laneLinearReference, projection, newRoadlink.linkLength, replaceInfo.digitizationChange)
        }
        val adjustment = LanePositionAdjustment(lane.id, newRoadlink.linkId, newStartM, newEndM, SideCode.apply(newSideCode))
        val adjustedLane = lane.copy(linkId = newRoadlink.linkId, startMeasure = newStartM, endMeasure = newEndM, sideCode = newSideCode)
        (adjustment, adjustedLane)
      })
      laneAdjustmentsOnLink
    })
  }
}
