package fi.liikennevirasto.digiroad2.util.assetUpdater

import fi.liikennevirasto.digiroad2.asset.SideCode.switch
import fi.liikennevirasto.digiroad2.asset.{AutoGeneratedUsername, SideCode}
import fi.liikennevirasto.digiroad2.client._
import fi.liikennevirasto.digiroad2.client.viite.SearchViiteClient
import fi.liikennevirasto.digiroad2.lane.LaneFiller._
import fi.liikennevirasto.digiroad2.lane.LaneNumber.isMainLane
import fi.liikennevirasto.digiroad2.lane._
import fi.liikennevirasto.digiroad2.service.lane.LaneService
import fi.liikennevirasto.digiroad2.service.{RoadAddressService, RoadLinkService}
import fi.liikennevirasto.digiroad2.util.{Digiroad2Properties, MainLanePopulationProcess}
import fi.liikennevirasto.digiroad2.{DummyEventBus, DummySerializer, GeometryUtils}
import org.apache.http.impl.client.HttpClientBuilder
import org.joda.time.DateTime
import org.slf4j.LoggerFactory

import java.text.SimpleDateFormat

object LaneUpdater {
  lazy val roadLinkChangeClient: RoadLinkChangeClient = new RoadLinkChangeClient
  lazy val roadLinkClient: RoadLinkClient = new RoadLinkClient(Digiroad2Properties.vvhRestApiEndPoint)
  lazy val roadLinkService: RoadLinkService = new RoadLinkService(roadLinkClient, new DummyEventBus, new DummySerializer)
  lazy val viiteClient: SearchViiteClient = new SearchViiteClient(Digiroad2Properties.viiteRestApiEndPoint, HttpClientBuilder.create().build())
  lazy val roadAddressService: RoadAddressService = new RoadAddressService(viiteClient)
  lazy val laneService: LaneService = new LaneService(roadLinkService, new DummyEventBus, roadAddressService)
  val username: String = "samuutus"
  private val logger = LoggerFactory.getLogger(getClass)
  def laneFiller: LaneFiller = new LaneFiller

  def getMainLaneAdjustments(mainLanes: Seq[PersistedLane], newRoadLink: RoadLinkInfo, digitizationChange: Boolean): Seq[LanePositionAdjustment] = {
    mainLanes.map(mainLane => {
      val sideCodeAdjustment = if (digitizationChange) {
        val newSideCode = SideCode.apply(mainLane.sideCode) match {
          case SideCode.AgainstDigitizing => SideCode.TowardsDigitizing.value
          case SideCode.TowardsDigitizing => SideCode.AgainstDigitizing.value
          case _ => mainLane.sideCode
        }
        SideCode.apply(newSideCode)
      }
      else SideCode.apply(mainLane.sideCode)
      val newEndMeasure = Math.round(newRoadLink.linkLength * 1000).toDouble / 1000
      val startMeasureAdjustment = 0.0
      val endMeasureAdjustment = newEndMeasure

      LanePositionAdjustment(mainLane.id, newRoadLink.linkId, startMeasureAdjustment, endMeasureAdjustment, sideCodeAdjustment)
    })
  }

  // TODO Lisäkaistojen yhdistely mahdollisesti tässä
  def moveLanesToMergedRoadLink(mergeChanges: Seq[RoadLinkChange], lanesOnOldLinks: Seq[PersistedLane], newMergedRoadLink: RoadLinkInfo): (Seq[LaneMerge], Seq[LanePositionAdjustment]) = {
    val (oldMainLanes, oldAdditionalLanes) = lanesOnOldLinks.partition(lane => LaneNumber.isMainLane(lane.laneCode))
    val mergedMainLanes = createMergedMainLanes(oldMainLanes, mergeChanges, newMergedRoadLink)

    val additionalLanePositionAdjustments = oldAdditionalLanes.map(lane => {
      val relevantChange = mergeChanges.find(_.oldLink.get.linkId == lane.linkId).get
      val relevantReplaceInfo = relevantChange.replaceInfo.find(_.oldLinkId == lane.linkId).get
      val newRoadLink = relevantChange.newLinks.head
      val newLinkId = newRoadLink.linkId
      val newLinkLength = newRoadLink.linkLength
      val (newStartM, newEndM, newSideCode) = calculateNewMValuesAndSideCode(lane, relevantReplaceInfo, newLinkLength)
      LanePositionAdjustment(lane.id, newLinkId, newStartM, newEndM, SideCode.apply(newSideCode))
    })

    (mergedMainLanes, additionalLanePositionAdjustments)
  }



  def updateChangeSet(changeSet: ChangeSet) : Unit = {

    def saveLanePositionAdjustments(positionAdjustments: Seq[LanePositionAdjustment]): Unit = {
      val toAdjustLanes = laneService.getPersistedLanesByIds(positionAdjustments.map(_.laneId).toSet, newTransaction = false)

      positionAdjustments.foreach { adjustment =>
        val oldLane = toAdjustLanes.find(_.id == adjustment.laneId)
        if(oldLane.nonEmpty){
          laneService.moveToHistory(oldLane.get.id, None, expireHistoryLane = false, deleteFromLanes = false, AutoGeneratedUsername.generatedInUpdate)
          laneService.dao.updateLanePositionAndModifiedDate(adjustment.laneId, adjustment.linkId, adjustment.startMeasure, adjustment.endMeasure, adjustment.sideCode.value, AutoGeneratedUsername.generatedInUpdate)
        }
        else{
          logger.error("Old lane not found with ID: " + adjustment.laneId + " Adjustment link ID: " + adjustment.linkId)
        }

      }
    }

    def saveMergeChanges(laneMerges: Seq[LaneMerge]): Unit = {
      val lanesToCreate = laneMerges.map(_.laneToCreate)
      val lanesToExpire = laneMerges.map(_.originalLanes)
      logger.info("Creating " + lanesToCreate.size + " new lanes due to merges on link ids: " +
        lanesToCreate.map(_.linkId).mkString(", "))

      val createdLaneIdsAndOriginalLanes = laneMerges.map(merge => {
        val createdLaneId = laneService.createWithoutTransaction(merge.laneToCreate, AutoGeneratedUsername.generatedInUpdate)
        (createdLaneId, merge.originalLanes)
      })

      logger.info("Expiring " + lanesToExpire.size + " old lanes due to merges on link ids: " +
        lanesToExpire.flatten.map(_.linkId).mkString(", "))

      // Each old lane must have history row referencing to each new lane created from it
      createdLaneIdsAndOriginalLanes.foreach(createdLaneIdAndOriginalLanes => {
        val createdLaneId = createdLaneIdAndOriginalLanes._1
        val originalLanes = createdLaneIdAndOriginalLanes._2

        originalLanes.foreach(originalLane => {
          laneService.moveToHistory(originalLane.id, Some(createdLaneId), expireHistoryLane = true, deleteFromLanes = true, AutoGeneratedUsername.generatedInUpdate)
        })
      })
    }


    def saveSplitChanges(laneSplits: Seq[LaneSplit]): Unit = {
      val lanesToCreate = laneSplits.flatMap(_.lanesToCreate).toSet
      val lanesToExpire = laneSplits.map(_.originalLane).toSet

      logger.info("Creating " + lanesToCreate.size + " new lanes due to split on link ids: " + lanesToCreate.map(_.linkId).mkString(", "))
      val createdLaneIdsWithOldLanes = laneSplits.map(split => {
        val createdLaneIds = split.lanesToCreate.map(laneToCreate => {laneService.createWithoutTransaction(laneToCreate, AutoGeneratedUsername.generatedInUpdate)})
        (createdLaneIds, split.originalLane)
      })

      // Each old lane must have history row referencing to each new lane created from it
      logger.info("Expiring " + lanesToExpire.size + " old lanes due to split on link ids: " + lanesToExpire.map(_.linkId).mkString(", "))
      createdLaneIdsWithOldLanes.foreach(createdLaneIdAndOldLane => {
        val createdLaneIds = createdLaneIdAndOldLane._1
        val originalLane = createdLaneIdAndOldLane._2
        createdLaneIds.foreach(newId => {
          laneService.moveToHistory(originalLane.id, Some(newId), expireHistoryLane = true, deleteFromLanes = false, AutoGeneratedUsername.generatedInUpdate)
        })
      })

      // After history is created, delete lanes
      logger.info("Deleting " + lanesToExpire.size + " old lanes due to split on linkIds: " + lanesToExpire.map(_.linkId).mkString(", "))
      lanesToExpire.foreach(laneToExpire => {
        laneService.dao.deleteEntryLane(laneToExpire.id)
      })
    }

    // Expire lanes marked to be expired
    val laneIdsToExpire = changeSet.expiredLaneIds.toSeq
    if (laneIdsToExpire.nonEmpty) {
      logger.info("Expiring ids: " + laneIdsToExpire.mkString(", "))
      laneIdsToExpire.foreach(laneId => {
        laneService.moveToHistory(laneId, None, expireHistoryLane = true, deleteFromLanes = true, AutoGeneratedUsername.generatedInUpdate)
      })
    }


    // Create generated new lanes
    if (changeSet.generatedPersistedLanes.nonEmpty){
      logger.info(s"${changeSet.generatedPersistedLanes.size} lanes created for ${changeSet.generatedPersistedLanes.map(_.linkId).toSet.size} links")
      laneService.createMultipleLanes(changeSet.generatedPersistedLanes, AutoGeneratedUsername.generatedInUpdate)
    }

    // Create new lanes, and expire old lanes due to road link splits
    if (changeSet.splitLanes.nonEmpty) {
      saveSplitChanges(changeSet.splitLanes)
    }

    // Create new merged lanes and expire old original lanes
    if (changeSet.mergedLanes.nonEmpty) {
      saveMergeChanges(changeSet.mergedLanes)
    }

    // Adjust m-values and side codes for lanes marked to be adjusted
    if (changeSet.positionAdjustments.nonEmpty) {
      logger.info("Saving SideCode/M-Value adjustments for lane Ids:" + changeSet.positionAdjustments.map(a => "" + a.laneId).mkString(", "))
      saveLanePositionAdjustments(changeSet.positionAdjustments)
    }

  }



  def updateLanes(): Unit = {
    val roadLinkChanges = roadLinkChangeClient.getRoadLinkChanges()
    handleChanges(roadLinkChanges)
  }

  def handleChanges(roadLinkChanges: Seq[RoadLinkChange]): Unit = {
    val oldLinkIds = roadLinkChanges.flatMap(_.oldLink).map(_.linkId)
    val lanesOnChangedLinks = laneService.fetchAllLanesByLinkIds(oldLinkIds, newTransaction = false)

    // Merge changes consist of multiple messages, group them and handle separately from rest of the changes
    val (mergeChanges, singleMessageChanges) = roadLinkChanges.partition(roadLinkChange => {
      val otherRoadLinkChanges = roadLinkChanges.filterNot(change => change == roadLinkChange)
      roadLinkChangeClient.partitionMergeChanges(roadLinkChange, otherRoadLinkChanges)
    })

    val mergeChangesGrouped = mergeChanges.groupBy(_.newLinks).values.toSeq
    val mergeChangeSets = mergeChangesGrouped.map(mergeChanges => {
      val oldLinkIds = mergeChanges.flatMap(_.oldLink).map(_.linkId)
      val newMergedRoadLink = mergeChanges.head.newLinks.head
      val lanesOnOldLinks = lanesOnChangedLinks.filter(lane => oldLinkIds.contains(lane.linkId))
      val (mainLaneMerges, additionalLanePositionAdjustments) = moveLanesToMergedRoadLink(mergeChanges, lanesOnOldLinks, newMergedRoadLink)
      ChangeSet(positionAdjustments = additionalLanePositionAdjustments, mergedLanes = mainLaneMerges)
    })

    val otherChangeSets = singleMessageChanges.map(change => {
      change.changeType match {
        case RoadLinkChangeType.Add =>
          val addedLinkIds = change.newLinks.map(_.linkId)
          // Need to fetch RoadLinks because Link Type is needed for main lane creation
          val addedRoadLinks = roadLinkService.getRoadLinksByLinkIds(addedLinkIds.toSet)
          val createdMainLanes = MainLanePopulationProcess.createMainLanesForRoadLinks(addedRoadLinks, saveResult = false)
          ChangeSet(generatedPersistedLanes = createdMainLanes)
        case RoadLinkChangeType.Remove =>
          val removedLinkId = change.oldLink.get.linkId
          val lanesToExpireOnRemovedLink = lanesOnChangedLinks.filter(_.linkId == removedLinkId).map(_.id).toSet
          ChangeSet(expiredLaneIds = lanesToExpireOnRemovedLink)
        case RoadLinkChangeType.Replace =>
          val lanesOnReplacedLink = lanesOnChangedLinks.filter(lane => change.oldLink.get.linkId == lane.linkId)
          val allLanePositionAdjustments = fillReplacementLinksWithExistingLanes(lanesOnReplacedLink, change)
          ChangeSet(positionAdjustments = allLanePositionAdjustments)
        case RoadLinkChangeType.Split =>
          val oldRoadLink = change.oldLink.get
          val lanesOnSplitLink = lanesOnChangedLinks.filter(_.linkId == oldRoadLink.linkId)
          val lanesOnSplitLinks = fillSplitLinksWithExistingLanes(lanesOnSplitLink, change)
          ChangeSet(splitLanes = lanesOnSplitLinks)
      }
    })


    val changeSet = (otherChangeSets ++ mergeChangeSets).foldLeft(ChangeSet())(LaneFiller.combineChangeSets)
    updateChangeSet(changeSet)
  }
  // In case main lane's parent lanes have different start dates, we want to inherit the latest date
  def inheritMergedMainLaneStartDate(originalLanes: Seq[PersistedLane]): Seq[LaneProperty] = {
    val startDateStrings = originalLanes.flatMap(parentLane => laneService.getPropertyValue(parentLane, "start_date")).map(_.value).asInstanceOf[Seq[String]]
    val dateFormat = new SimpleDateFormat("d.M.yyyy")
    val startDates = startDateStrings.map(dateString => dateFormat.parse(dateString))
    val latestDate = startDates.min
    val latestDateString = dateFormat.format(latestDate)

    val lanePropertiesToUse = Seq(
      LaneProperty("lane_code", Seq(LanePropertyValue(LaneNumber.MainLane.oneDigitLaneCode))),
      LaneProperty("lane_type", Seq(LanePropertyValue(LaneType.Main.value))),
      LaneProperty("start_date", Seq(LanePropertyValue(latestDateString)))
    )

    lanePropertiesToUse
  }

  def calculateNewMValuesAndSideCode(lane: PersistedLane, replaceInfo: ReplaceInfo,
                                     roadLinkLength: Double): (Double, Double, Int) = {

    val oldLength = replaceInfo.oldToMValue - replaceInfo.oldFromMValue
    val newLength = replaceInfo.newToMValue - replaceInfo.newFromMValue

    // Test if the direction has changed -> side code will be affected, too
    if (replaceInfo.digitizationChange) {
      val newSideCode = switch(SideCode.apply(lane.sideCode)).value

      val newStart = replaceInfo.newFromMValue - (lane.endMeasure - replaceInfo.oldFromMValue) * Math.abs(newLength / oldLength)
      val newEnd = replaceInfo.newToMValue - (lane.startMeasure - replaceInfo.oldToMValue) * Math.abs(newLength / oldLength)

      // Test if asset is affected by projection
      if (lane.endMeasure <= replaceInfo.oldFromMValue || lane.startMeasure >= replaceInfo.oldToMValue)
        (lane.startMeasure, lane.endMeasure, newSideCode)
      else {
        val newStartMRounded = (Math.round(newStart * 1000).toDouble / 1000)
        val newEndMRounded = (Math.round(newEnd * 1000).toDouble / 1000)
        (Math.min(roadLinkLength, Math.max(0.0, newStartMRounded)), Math.max(0.0, Math.min(roadLinkLength, newEndMRounded)), newSideCode)
      }
    } else {
      val newStart = replaceInfo.newFromMValue + (lane.startMeasure - replaceInfo.oldFromMValue) * Math.abs(newLength / oldLength)
      val newEnd = replaceInfo.newToMValue + (lane.endMeasure - replaceInfo.oldToMValue) * Math.abs(newLength / oldLength)

      // Test if asset is affected by projection
      if (lane.endMeasure <= replaceInfo.oldFromMValue || lane.startMeasure >= replaceInfo.oldToMValue) {
        (lane.startMeasure, lane.endMeasure, lane.sideCode)
      } else {
        val newStartMRounded = (Math.round(newStart * 1000).toDouble / 1000)
        val newEndMRounded = (Math.round(newEnd * 1000).toDouble / 1000)
        (Math.min(roadLinkLength, Math.max(0.0, newStartMRounded)), Math.max(0.0, Math.min(roadLinkLength, newEndMRounded)), lane.sideCode)
      }
    }
  }

  def calculateAdditionalLanePositionsOnSplitLinks(oldAdditionalLanes: Seq[PersistedLane], change: RoadLinkChange): Seq[LaneSplit] = {
    oldAdditionalLanes.map(originalAdditionalLane => {
      val replaceInfosAffectingLane = change.replaceInfo.filter(replaceInfo => {
        GeometryUtils.liesInBetween(replaceInfo.oldFromMValue, (originalAdditionalLane.startMeasure, originalAdditionalLane.endMeasure)) ||
          GeometryUtils.liesInBetween(replaceInfo.oldToMValue, (originalAdditionalLane.startMeasure, originalAdditionalLane.endMeasure))
      })
      val lanesSplitFromOriginal = replaceInfosAffectingLane.map(replaceInfo => {
        val newRoadLinkLength = change.newLinks.find(_.linkId == replaceInfo.newLinkId).get.linkLength
        val (newStartM, newEndM, newSideCode) = calculateNewMValuesAndSideCode(originalAdditionalLane, replaceInfo, newRoadLinkLength)
        originalAdditionalLane.copy(startMeasure = newStartM, endMeasure = newEndM, linkId = replaceInfo.newLinkId, sideCode = newSideCode)
      })
      LaneSplit(lanesSplitFromOriginal, originalAdditionalLane)
    })
  }

  def createSplitMainLanes(oldMainLanes: Seq[PersistedLane], splitChange: RoadLinkChange): Seq[LaneSplit] = {
    oldMainLanes.map(originalMainLane => {
      val replaceInfos = splitChange.replaceInfo
      val splitMainLanesToCreate = replaceInfos.map(replaceInfo => {
        val newSideCode = if(replaceInfo.digitizationChange) switch(SideCode.apply(originalMainLane.sideCode)).value
        else originalMainLane.sideCode
        val splitLaneStartMeasure = 0.0
        val splitLaneEndMeasure = Math.round(replaceInfo.newToMValue * 1000).toDouble / 1000
        originalMainLane.copy(id = 0, linkId = replaceInfo.newLinkId, sideCode = newSideCode, startMeasure = splitLaneStartMeasure, endMeasure = splitLaneEndMeasure)
      })
      LaneSplit(splitMainLanesToCreate, originalMainLane)
    })
  }

  def createMergedMainLanes(oldMainLanes: Seq[PersistedLane], mergeChanges: Seq[RoadLinkChange], mergedRoadLink: RoadLinkInfo): Seq[LaneMerge] = {
    val oldMainLanesGroupedBySideCode = oldMainLanes.groupBy(originalMainLane => {
      val relevantReplaceInfo = mergeChanges.flatMap(_.replaceInfo).find(_.oldLinkId == originalMainLane.linkId).get
      if(relevantReplaceInfo.digitizationChange) switch(SideCode.apply(originalMainLane.sideCode)).value
      else originalMainLane.sideCode
    })

    oldMainLanesGroupedBySideCode.map(mainLanesGrouped => {
      val mergedLaneSideCode = mainLanesGrouped._1
      val mainLanesToMerge = mainLanesGrouped._2

      val mergedMainLaneStartMeasure = 0.0
      //TODO Tähän joku nätimpi ratkaisu, kaikkien muutosviestien newLinks pitäisi sisältää kyllä vain yksi ja sama uusi tielinkki, joten tämäkin pitäisi toimia
      val mergedMainLaneEndMeasure = mergedRoadLink.linkLength
      val mergedMainLaneEndMeasureRounded = Math.round(mergedMainLaneEndMeasure * 1000).toDouble / 1000
      val inheritedAttributes = inheritMergedMainLaneStartDate(mainLanesToMerge)


      val mergedMainLaneToCreate = PersistedLane(id = 0, linkId = mergedRoadLink.linkId, sideCode = mergedLaneSideCode, laneCode = LaneNumber.MainLane.oneDigitLaneCode,
        municipalityCode = mergedRoadLink.municipality, startMeasure = mergedMainLaneStartMeasure, endMeasure = mergedMainLaneEndMeasureRounded, createdBy = None,
        createdDateTime = None, modifiedBy = None, modifiedDateTime = None, expiredBy = None, expiredDateTime = None, expired = false,
        timeStamp = DateTime.now().getMillis , geomModifiedDate = None, attributes = inheritedAttributes)

      LaneMerge(mergedMainLaneToCreate, mainLanesToMerge)
    }).toSeq
  }

  def fillSplitLinksWithExistingLanes(lanesToUpdate: Seq[PersistedLane], change: RoadLinkChange): Seq[LaneSplit] = {
    val (mainLanesOnOldLink, additionalLanesOnOldLink) = lanesToUpdate.partition(lane => isMainLane(lane.laneCode))
    val mainLaneSplits = createSplitMainLanes(mainLanesOnOldLink, change)
    val additionalLaneSplits = calculateAdditionalLanePositionsOnSplitLinks(additionalLanesOnOldLink, change)
    mainLaneSplits ++ additionalLaneSplits
  }

  // Replacement käsittely lisäkaistoille
  def fillReplacementLinksWithExistingLanes(lanesToUpdate: Seq[PersistedLane], change: RoadLinkChange): Seq[LanePositionAdjustment] = {
    val newRoadLinks = change.newLinks
    val allLaneAdjustments = newRoadLinks.flatMap(newRoadlink => {
      val replaceInfo = change.replaceInfo.find(_.newLinkId == newRoadlink.linkId).get
      val digitizationChange = change.replaceInfo.find(_.newLinkId == newRoadlink.linkId).get.digitizationChange
      val (mainLanes, additionalLanes) = lanesToUpdate.partition(lane => isMainLane(lane.laneCode))

      val mainLaneAdjustments = getMainLaneAdjustments(mainLanes, newRoadlink, digitizationChange)

      // TODO Projection toiminta kunnolla selväksi, Option käsittely
      // TODO SideCode muuttaminen yhteisesti kaikille caseille myöhemmin?
      // TODO Turhien adjustment karsiminen
      val additionalLaneAdjustments = additionalLanes.map(additionalLane => {
        val (newStartM, newEndM, newSideCode) = calculateNewMValuesAndSideCode(additionalLane, replaceInfo, newRoadlink.linkLength)
        LanePositionAdjustment(additionalLane.id, newRoadlink.linkId, newStartM, newEndM, SideCode.apply(newSideCode))
      })

      mainLaneAdjustments ++ additionalLaneAdjustments
    })

    allLaneAdjustments
  }
}
