package fi.liikennevirasto.digiroad2.util

import fi.liikennevirasto.digiroad2.asset.{AutoGeneratedUsername, CycleOrPedestrianPath, LinkType, ServiceAccess, SpecialTransportWithGate, SpecialTransportWithoutGate, TractorRoad, TrafficDirection, BidirectionalLaneCarriageWay, RestArea}
import fi.liikennevirasto.digiroad2.asset.TrafficDirection.toSideCode
import fi.liikennevirasto.digiroad2.client.viite.SearchViiteClient
import fi.liikennevirasto.digiroad2.{DummyEventBus, DummySerializer, lane}
import fi.liikennevirasto.digiroad2.client.RoadLinkClient
import fi.liikennevirasto.digiroad2.dao.Queries
import fi.liikennevirasto.digiroad2.lane.{LaneProperty, LanePropertyValue, LaneType, PersistedLane}
import fi.liikennevirasto.digiroad2.linearasset.RoadLink
import fi.liikennevirasto.digiroad2.postgis.PostGISDatabase
import fi.liikennevirasto.digiroad2.service.{RoadAddressService, RoadLinkService}
import fi.liikennevirasto.digiroad2.service.lane.LaneService
import org.apache.http.impl.client.HttpClientBuilder
import org.joda.time.DateTime
import org.slf4j.LoggerFactory

import java.text.SimpleDateFormat

object MainLanePopulationProcess {

  lazy val roadLinkClient: RoadLinkClient = {
    new RoadLinkClient()
  }

  lazy val roadLinkService: RoadLinkService = {
    new RoadLinkService(roadLinkClient, new DummyEventBus, new DummySerializer)
  }

  lazy val roadAddressService: RoadAddressService = {
    val viiteClient = new SearchViiteClient(Digiroad2Properties.viiteRestApiEndPoint, HttpClientBuilder.create().build())
    new RoadAddressService(viiteClient)
  }

  lazy val laneService: LaneService = {
    new LaneService(roadLinkService, new DummyEventBus, roadAddressService)
  }

  lazy val twoWayLanes: Seq[LinkType] = Seq(
      SpecialTransportWithoutGate, SpecialTransportWithGate, ServiceAccess, CycleOrPedestrianPath, BidirectionalLaneCarriageWay, RestArea)

  private val logger = LoggerFactory.getLogger(getClass)

  private def addMainLane(roadLink: RoadLink): PersistedLane = {
    val createdTimeStamp = LinearAssetUtils.createTimeStamp()
    val sideCode = toSideCode(roadLink.trafficDirection).value
    val laneCode = 1
    val startMeasure = 0.0
    // Use three decimals
    val endMeasure = Math.round(roadLink.length * 1000).toDouble / 1000
    val dateFormat = new SimpleDateFormat("d.M.yyyy")
    val startDate = dateFormat.format(DateTime.now().toDate)

    val laneProperties = Seq(
      LaneProperty("lane_code", Seq(LanePropertyValue(laneCode))),
      LaneProperty("lane_type", Seq(LanePropertyValue(LaneType.Main.value))),
      LaneProperty("start_date", Seq(LanePropertyValue(startDate)))
    )

    PersistedLane(0, roadLink.linkId, sideCode, laneCode, roadLink.municipalityCode, startMeasure, endMeasure,
      Some(AutoGeneratedUsername.autoGeneratedLane), Some(DateTime.now()), None, None, None, None, expired = false,
      createdTimeStamp, None, laneProperties)
  }

  // Split road links by traffic direction
  // Two way lanes allowed only for links that are service openings, cycle or pedestrian path, or tractor road
  private def splitLinksByTrafficDirection(roadLink: RoadLink): Seq[RoadLink] = {
    val twoWayLane = twoWayLanes.contains(roadLink.linkType)
    roadLink.trafficDirection match {
      case TrafficDirection.BothDirections if !twoWayLane =>
        Seq(roadLink.copy(trafficDirection = TrafficDirection.TowardsDigitizing),
            roadLink.copy(trafficDirection = TrafficDirection.AgainstDigitizing))
      case _ if twoWayLane =>
        if (roadLink.linkType == RestArea) Seq(roadLink)
        else Seq(roadLink.copy(trafficDirection = TrafficDirection.BothDirections))
      case _ =>
        Seq(roadLink)
    }
  }

  private def mainLanesForMunicipality(municipality: Int): Unit = {
    logger.info("Working on municipality -> " + municipality)

    val roadLinks = roadLinkService.getRoadLinksByMunicipality(municipality).filterNot(_.linkType == TractorRoad)

    // If not initial process, filter out roadLinks that already have main lanes
    val roadLinksWithoutMainLanes = {
      val existingLanes = laneService.fetchExistingMainLanesByRoadLinks(roadLinks, Seq()).groupBy(_.linkId)
      roadLinks.filterNot(roadLink => existingLanes.exists(_._1 == roadLink.linkId))
    }

    logger.info(roadLinksWithoutMainLanes.length + " road links without main lanes.")
    createMainLanesForRoadLinks(roadLinksWithoutMainLanes, newTransaction = true)
  }

  def createMainLanesForRoadLinks(roadLinksWithoutMainLanes: Seq[RoadLink], saveResult: Boolean = true, newTransaction: Boolean = false): Seq[PersistedLane] = {
    val municipalityMainLanes = roadLinksWithoutMainLanes.flatMap { roadLink =>
      splitLinksByTrafficDirection(roadLink).map { linkWithUpdatedDirection =>
        addMainLane(linkWithUpdatedDirection)
      }
    }

    if (municipalityMainLanes.nonEmpty && saveResult) {
      val lanes = laneService.createMultipleLanes(municipalityMainLanes, AutoGeneratedUsername.autoGeneratedLane, newTransaction)
      logger.info(s"${lanes.size} lanes created for ${roadLinksWithoutMainLanes.size} links")
      lanes
    }

    else municipalityMainLanes
  }

  def process(): Unit = {
    logger.info(s"Start to populate main lanes from road links ${DateTime.now()}")

    val municipalities: Seq[Int] = PostGISDatabase.withDynSession {
      Queries.getMunicipalities
    }

    municipalities.foreach { municipality =>
      mainLanesForMunicipality(municipality)
    }

    logger.info(s"Finished populating main lanes ${DateTime.now()}")
  }

}