package fi.liikennevirasto.digiroad2.util.assetUpdater

import com.github.tototoshi.csv.CSVWriter
import fi.liikennevirasto.digiroad2.asset.ConstructionType.InUse
import fi.liikennevirasto.digiroad2.asset._
import fi.liikennevirasto.digiroad2.client.FeatureClass.WinterRoads
import fi.liikennevirasto.digiroad2.client.RoadLinkChangeType.{Add, Remove}
import fi.liikennevirasto.digiroad2.client._
import fi.liikennevirasto.digiroad2.dao.RoadLinkOverrideDAO
import fi.liikennevirasto.digiroad2.dao.RoadLinkOverrideDAO.{AdministrativeClass, TrafficDirection, _}
import fi.liikennevirasto.digiroad2.linearasset.RoadLink
import fi.liikennevirasto.digiroad2.postgis.PostGISDatabase
import fi.liikennevirasto.digiroad2.service.{AwsService, IncompleteLink, RoadLinkService}
import fi.liikennevirasto.digiroad2.util.{Digiroad2Properties, KgvUtil, LinearAssetUtils}
import fi.liikennevirasto.digiroad2.{DummyEventBus, DummySerializer}
import org.joda.time.DateTime
import org.json4s._
import org.json4s.jackson.Serialization
import slick.driver.JdbcDriver.backend.Database.dynamicSession
import slick.jdbc.StaticQuery.interpolation

import java.io.StringWriter
import scala.collection.mutable.ListBuffer

sealed trait ReportedChange {
  def linkId: String
  def changeType: RoadLinkChangeType
}

case class AdministrativeClassChange(linkId: String, changeType: RoadLinkChangeType, oldValue: Int, newValue: Option[Int]) extends ReportedChange
case class TrafficDirectionChange(linkId: String, changeType: RoadLinkChangeType, oldValue: Int, newValue: Option[Int]) extends ReportedChange
case class RoadLinkAttributeChange(linkId: String, changeType: RoadLinkChangeType, oldValues: Map[String, String], newValues: Map[String, String]) extends ReportedChange
case class FunctionalClassChange(linkId: String, changeType: RoadLinkChangeType, oldValue: Option[Int], newValue: Option[Int], source: String = "") extends ReportedChange
case class LinkTypeChange(linkId: String, changeType: RoadLinkChangeType, oldValue: Option[Int], newValue: Option[Int], source: String = "") extends ReportedChange

class RoadLinkPropertyUpdater {

  lazy val roadLinkService: RoadLinkService = new RoadLinkService(new RoadLinkClient(Digiroad2Properties.vvhRestApiEndPoint), new DummyEventBus, new DummySerializer)
  lazy val roadLinkChangeClient: RoadLinkChangeClient = new RoadLinkChangeClient
  lazy val awsService = new AwsService
  lazy val s3Service: awsService.S3.type = awsService.S3
  lazy val s3Bucket: String = Digiroad2Properties.samuutusReportsBucketName
  implicit lazy val serializationFormats: Formats = DefaultFormats

  def withDynTransaction[T](f: => T): T = PostGISDatabase.withDynTransaction(f)

  def generateFunctionalClass(changeType: RoadLinkChangeType, newLink: RoadLinkInfo): Option[FunctionalClassChange] = {
    val featureClass = KgvUtil.extractFeatureClass(newLink.roadClass)
    val timeStamp = DateTime.now().toString()
    featureClass match {
      case FeatureClass.TractorRoad =>
        FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), PrimitiveRoad.value, timeStamp)
        Some(FunctionalClassChange(newLink.linkId, changeType, null, Some(PrimitiveRoad.value), "mtkClass"))
      case FeatureClass.HardShoulder =>
        FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), FunctionalClass9.value, timeStamp)
        Some(FunctionalClassChange(newLink.linkId, changeType, null, Some(FunctionalClass9.value), "mtkClass"))
      case FeatureClass.DrivePath | FeatureClass.CarRoad_IIIb =>
        FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), AnotherPrivateRoad.value, timeStamp)
        Some(FunctionalClassChange(newLink.linkId, changeType, null, Some(AnotherPrivateRoad.value), "mtkClass"))
      case FeatureClass.CycleOrPedestrianPath =>
        FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), WalkingAndCyclingPath.value, timeStamp)
        Some(FunctionalClassChange(newLink.linkId, changeType, null, Some(WalkingAndCyclingPath.value), "mtkClass"))
      case FeatureClass.SpecialTransportWithoutGate =>
        FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), UnknownFunctionalClass.value, timeStamp)
        Some(FunctionalClassChange(newLink.linkId, changeType, null, Some(UnknownFunctionalClass.value), "mtkClass"))
      case FeatureClass.SpecialTransportWithGate =>
        FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), UnknownFunctionalClass.value, timeStamp)
        Some(FunctionalClassChange(newLink.linkId, changeType, null, Some(UnknownFunctionalClass.value), "mtkClass"))
      case FeatureClass.CarRoad_IIIa => newLink.adminClass match {
        case State =>
          FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), FunctionalClass4.value, timeStamp)
          Some(FunctionalClassChange(newLink.linkId, changeType, null, Some(FunctionalClass4.value), "mtkClass"))
        case Municipality | Private =>
          FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), FunctionalClass5.value, timeStamp)
          Some(FunctionalClassChange(newLink.linkId, changeType, null, Some(FunctionalClass5.value), "mtkClass"))
        case _ => None
      }
      case _ => None
    }
  }

  def generateLinkType(changeType: RoadLinkChangeType, newLink: RoadLinkInfo): Option[LinkTypeChange] = {
    val featureClass = KgvUtil.extractFeatureClass(newLink.roadClass)
    val timeStamp = DateTime.now().toString()
    featureClass match {
      case FeatureClass.TractorRoad =>
        LinkTypeDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), TractorRoad.value, timeStamp)
        Some(LinkTypeChange(newLink.linkId, changeType, null, Some(TractorRoad.value), "mtkClass"))
      case FeatureClass.HardShoulder =>
        LinkTypeDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), HardShoulder.value, timeStamp)
        Some(LinkTypeChange(newLink.linkId, changeType, null, Some(HardShoulder.value), "mtkClass"))
      case FeatureClass.DrivePath | FeatureClass.CarRoad_IIIb =>
        LinkTypeDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), SingleCarriageway.value, timeStamp)
        Some(LinkTypeChange(newLink.linkId, changeType, null, Some(SingleCarriageway.value), "mtkClass"))
      case FeatureClass.CycleOrPedestrianPath =>
        LinkTypeDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), CycleOrPedestrianPath.value, timeStamp)
        Some(LinkTypeChange(newLink.linkId, changeType, null, Some(CycleOrPedestrianPath.value), "mtkClass"))
      case FeatureClass.SpecialTransportWithoutGate =>
        LinkTypeDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), SpecialTransportWithoutGate.value, timeStamp)
        Some(LinkTypeChange(newLink.linkId, changeType, null, Some(SpecialTransportWithoutGate.value), "mtkClass"))
      case FeatureClass.SpecialTransportWithGate =>
        LinkTypeDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), SpecialTransportWithGate.value, timeStamp)
        Some(LinkTypeChange(newLink.linkId, changeType, null, Some(SpecialTransportWithGate.value), "mtkClass"))
      case FeatureClass.CarRoad_IIIa =>
        LinkTypeDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), SingleCarriageway.value, timeStamp)
        Some(LinkTypeChange(newLink.linkId, changeType, null, Some(SingleCarriageway.value), "mtkClass"))
      case _ => None
    }
  }

  def incompleteLinkIsInUse(incompleteLink: IncompleteLink, roadLinkData: Seq[RoadLink]) = {
    val correspondingRoadLink = roadLinkData.find(_.linkId == incompleteLink.linkId)
    correspondingRoadLink match {
      case Some(roadLink) => roadLink.constructionType == InUse
      case _ => false
    }
  }

  def transferFunctionalClassAndLinkTypeFromOldLinks(changeType: RoadLinkChangeType, optionalOldLink: Option[RoadLinkInfo], newLink: RoadLinkInfo): (Option[FunctionalClassChange], Option[LinkTypeChange]) = {
    val timeStamp = DateTime.now().toString()
    optionalOldLink match {
      case Some(oldLink) =>
        val optionalFunctionalClass = FunctionalClassDao.getExistingValue(oldLink.linkId)
        val optionalLinkType = LinkTypeDao.getExistingValue(oldLink.linkId)
        (optionalFunctionalClass, optionalLinkType) match {
          case (Some(functionalClass), Some(linkType)) =>
            FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), functionalClass, timeStamp)
            LinkTypeDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), linkType, timeStamp)
            (Some(FunctionalClassChange(newLink.linkId, changeType, Some(functionalClass), Some(functionalClass), "oldLink")),
              Some(LinkTypeChange(newLink.linkId, changeType, Some(linkType), Some(linkType), "oldLink")))
          case (Some(functionalClass), None) =>
            FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), functionalClass, timeStamp)
            (Some(FunctionalClassChange(newLink.linkId, changeType, Some(functionalClass), Some(functionalClass), "oldLink")), None)
          case (None, Some(linkType)) =>
            LinkTypeDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), linkType, timeStamp)
            (None, Some(LinkTypeChange(newLink.linkId, changeType, Some(linkType), Some(linkType), "oldLink")))
          case _ => (None, None)
          }
      case _ => (None, None)
    }
  }

  def transferOrGenerateFunctionalClassesAndLinkTypes(changes: Seq[RoadLinkChange]) = {
    val incompleteLinks = new ListBuffer[IncompleteLink]()
    val createdProperties = new ListBuffer[Option[ReportedChange]]()
    changes.foreach { change =>
      change.newLinks foreach { newLink =>
        if (KgvUtil.extractFeatureClass(newLink.roadClass) != WinterRoads) {
          var (functionalClassChange, linkTypeChange) = transferFunctionalClassAndLinkTypeFromOldLinks(change.changeType, change.oldLink, newLink)
          if (functionalClassChange.isEmpty) {
            functionalClassChange = generateFunctionalClass(change.changeType, newLink)
          }
          if (linkTypeChange.isEmpty) {
            linkTypeChange = generateLinkType(change.changeType, newLink)
          }
          if (functionalClassChange.isEmpty || linkTypeChange.isEmpty) {
            incompleteLinks += IncompleteLink(newLink.linkId, newLink.municipality, newLink.adminClass)
          }
          createdProperties += functionalClassChange
        }
      }
    }
    val roadLinkData = roadLinkService.getRoadLinksByLinkIds(incompleteLinks.map(_.linkId).toSet, false)
    val incompleteLinksInUse = incompleteLinks.filter(il => incompleteLinkIsInUse(il, roadLinkData))
    roadLinkService.updateIncompleteLinks(incompleteLinksInUse)
    createdProperties.flatten
  }

  def removePropertiesFromOldLinks(changes: Seq[RoadLinkChange]) = {
    val groupedChanges = changes.groupBy(_.oldLink.get.linkId)
    val oldLinkIds = changes.map(_.oldLink.get.linkId)
    val deletedTrafficDirections = TrafficDirectionDao.getExistingValues(oldLinkIds).map(deletion =>
      TrafficDirectionChange(deletion.linkId, groupedChanges(deletion.linkId).head.changeType, deletion.value.get, None))
    val deletedAdministrativeClasses = AdministrativeClassDao.getExistingValues(oldLinkIds).map(deletion =>
      AdministrativeClassChange(deletion.linkId, groupedChanges(deletion.linkId).head.changeType, deletion.value.get, None))
    val deletedFunctionalClasses = FunctionalClassDao.getExistingValues(oldLinkIds).map(deletion =>
      FunctionalClassChange(deletion.linkId, groupedChanges(deletion.linkId).head.changeType, deletion.value, None))
    val deletedLinkTypes = LinkTypeDao.getExistingValues(oldLinkIds).map(deletion =>
      LinkTypeChange(deletion.linkId, groupedChanges(deletion.linkId).head.changeType, deletion.value, None))
    val deletedAttributes = oldLinkIds.map(linkId => {
      val oldAttributes = LinkAttributesDao.getExistingValues(linkId)
      RoadLinkAttributeChange(linkId, groupedChanges(linkId).head.changeType, oldAttributes, Map())
    })
    val deletedProperties: Seq[ReportedChange] = deletedTrafficDirections ++ deletedAdministrativeClasses ++ deletedFunctionalClasses ++ deletedLinkTypes ++ deletedAttributes

    oldLinkIds.foreach { linkId =>
      TrafficDirectionDao.deleteValues(linkId)
      LinkTypeDao.deleteValues(linkId)
      FunctionalClassDao.deleteValues(linkId)
      AdministrativeClassDao.expireValues(linkId, Some(AutoGeneratedUsername.automaticAdjustment), Some(LinearAssetUtils.createTimeStamp()))
      LinkAttributesDao.expireValues(linkId, Some(AutoGeneratedUsername.automaticAdjustment), Some(LinearAssetUtils.createTimeStamp()))
    }
    deletedProperties
  }

  def transferOverriddenPropertiesAndPrivateRoadInfo(changes: Seq[RoadLinkChange]) = {
    val transferredProperties = ListBuffer[ReportedChange]()
    changes.foreach { change =>
      val oldLink = change.oldLink.get
      val optionalOverriddenTrafficDirection = TrafficDirectionDao.getExistingValue(oldLink.linkId)
      optionalOverriddenTrafficDirection match {
        case Some(overriddenTrafficDirection) =>
          change.newLinks.foreach { newLink =>
            if (overriddenTrafficDirection != newLink.trafficDirection.value) {
              RoadLinkOverrideDAO.insert(TrafficDirection, newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), overriddenTrafficDirection)
              transferredProperties += TrafficDirectionChange(newLink.linkId, change.changeType, oldLink.trafficDirection.value, Some(newLink.trafficDirection.value))
            }
          }
        case _ => //do nothing
      }

      val optionalOverriddenAdminClass = AdministrativeClassDao.getExistingValue(oldLink.linkId)
      optionalOverriddenAdminClass match {
        case Some(overriddenAdminClass) =>
          change.newLinks.foreach { newLink =>
            if (overriddenAdminClass != newLink.adminClass.value) {
              RoadLinkOverrideDAO.insert(AdministrativeClass, newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), overriddenAdminClass)
              transferredProperties += AdministrativeClassChange(newLink.linkId, change.changeType, oldLink.adminClass.value, Some(newLink.adminClass.value))
            }
          }
        case _ => //do nothing
      }

      val roadLinkAttributes = LinkAttributesDao.getExistingValues(oldLink.linkId)
      change.newLinks.foreach { newLink =>
        roadLinkAttributes.foreach { attribute =>
          LinkAttributesDao.insertAttributeValueByChanges(newLink.linkId, AutoGeneratedUsername.automaticGeneration, attribute._1, attribute._2, LinearAssetUtils.createTimeStamp())
        }
        transferredProperties += RoadLinkAttributeChange(newLink.linkId, change.changeType, roadLinkAttributes, roadLinkAttributes)
      }
    }
    transferredProperties
  }

  private def getCSVRow(linkId: String, changeType: RoadLinkChangeType, changes: Seq[ReportedChange]) = {
    val trafficDirectionChange = changes.find(_.isInstanceOf[TrafficDirectionChange])
    val (oldTrafficDirection, newTrafficDirection) = trafficDirectionChange match {
      case trChange: Some[TrafficDirectionChange] =>
        val oldValue = trChange.get.oldValue
        val newValue = trChange.get.newValue match {
          case Some(value) => value
          case _ => null
        }
        (oldValue, newValue)
      case _ => (null, null)
    }
    val adminClassChange = changes.find(_.isInstanceOf[AdministrativeClassChange])
    val (oldAdminClass, newAdminClass) = adminClassChange match {
      case acChange: Some[AdministrativeClassChange] =>
        val oldValue = acChange.get.oldValue
        val newValue = acChange.get.newValue match {
          case Some(value) => value
          case _ => null
        }
        (oldValue, newValue)
      case _ => (null, null)
    }
    val functionalClassChange = changes.find(_.isInstanceOf[FunctionalClassChange])
    val (oldFunctionalClass, newFunctionalClass, fcSource) = functionalClassChange match {
      case fcChange: Some[FunctionalClassChange] =>
        val oldValue = fcChange.get.oldValue match {
          case Some(value) => value
          case _ => null
        }
        val newValue = fcChange.get.newValue match {
          case Some(value) => value
          case _ => null
        }
        val source = fcChange.get.source
        (oldValue, newValue, source)
      case _ => (null, null, null)
    }
    val linkTypeChange = changes.find(_.isInstanceOf[LinkTypeChange])
    val (oldLinkType, newLinkType, ltSource) = linkTypeChange match {
      case ltChange: Some[LinkTypeChange] =>
        val oldValue = ltChange.get.oldValue match {
          case Some(value) => value
          case _ => null
        }
        val newValue = ltChange.get.newValue match {
          case Some(value) => value
          case _ => null
        }
        val source = ltChange.get.source
        (oldValue, newValue, source)
      case _ => (null, null, null)
    }
    val attributeChange = changes.find(_.isInstanceOf[RoadLinkAttributeChange])
    val (oldAttributes, newAttributes) = attributeChange match {
      case attributeChange: Some[RoadLinkAttributeChange] =>
        (Serialization.write(attributeChange.get.oldValues), Serialization.write(attributeChange.get.newValues))

      case _ => (None, None)
    }
    Seq(linkId, changeType.toString, oldTrafficDirection, newTrafficDirection, oldAdminClass, newAdminClass, oldFunctionalClass,
      newFunctionalClass, fcSource, oldLinkType, newLinkType, ltSource, oldAttributes, newAttributes)
  }

  def generateCSV(changes: Seq[ReportedChange]) = {

    val stringWriter = new StringWriter()
    val csvWriter = new CSVWriter(stringWriter)
    val labels = Seq("linkId", "changeType", "oldTrafficDirection", "newTrafficDirection", "oldAdminClass", "newAdminClass", "oldFunctionalClass",
      "newFunctionalClass", "functionalClassSource", "oldLinkType", "newLinkType", "linkTypeSource", "oldLinkAttributes", "newLinkAttributes")
    csvWriter.writeRow(labels)
    val linkIds = changes.map(_.linkId)
    linkIds.foreach { linkId =>
      val propertyChangesForLink = changes.filter(_.linkId == linkId)
      val changeType = propertyChangesForLink.head.changeType
      val csvRow = getCSVRow(linkId, changeType, propertyChangesForLink)
      csvWriter.writeRow(csvRow)
    }
    (stringWriter.toString, changes.size - 1)
  }

  def saveReportToS3(assetName: String, body: String, contentRowCount: Int) = {
    val date = DateTime.now().toString("YYYY-MM-dd")
    val path = s"${date}/${assetName}_${date}_${contentRowCount}content_rows.csv"
    s3Service.saveFileToS3(s3Bucket, path, body, "csv")
  }

  def updateSamuutusSuccess() = {
      sqlu"""INSERT INTO samuutus_success(asset_type_id, last_succesfull_samuutus)
           VALUES (99, current_timestamp)
      """.execute
  }

  def updateProperties() = {
    val changes = roadLinkChangeClient.getRoadLinkChanges()
    val (addChanges, remaining) = changes.partition(_.changeType == Add)
    val (removeChanges, otherChanges) = remaining.partition(_.changeType == Remove)

    withDynTransaction {
      val transferredProperties = transferOverriddenPropertiesAndPrivateRoadInfo(otherChanges)
      val createdProperties = transferOrGenerateFunctionalClassesAndLinkTypes(addChanges ++ otherChanges)
      val deletedProperties = removePropertiesFromOldLinks(removeChanges ++ otherChanges)
      val allChanges = transferredProperties ++ createdProperties ++ deletedProperties
      val (reportBody, contentRowCount) = generateCSV(allChanges)
      saveReportToS3("roadLinkProperties", reportBody, contentRowCount)
      updateSamuutusSuccess()
    }
  }
}
