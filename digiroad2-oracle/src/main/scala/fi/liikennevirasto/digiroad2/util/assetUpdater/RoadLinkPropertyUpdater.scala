package fi.liikennevirasto.digiroad2.util.assetUpdater

import fi.liikennevirasto.digiroad2.asset.ConstructionType.InUse
import fi.liikennevirasto.digiroad2.asset._
import fi.liikennevirasto.digiroad2.client.FeatureClass.WinterRoads
import fi.liikennevirasto.digiroad2.client.RoadLinkChangeType.{Add, Remove}
import fi.liikennevirasto.digiroad2.client._
import fi.liikennevirasto.digiroad2.dao.RoadLinkOverrideDAO
import fi.liikennevirasto.digiroad2.dao.RoadLinkOverrideDAO.{AdministrativeClass, TrafficDirection, _}
import fi.liikennevirasto.digiroad2.linearasset.RoadLink
import fi.liikennevirasto.digiroad2.postgis.PostGISDatabase
import fi.liikennevirasto.digiroad2.service.{IncompleteLink, RoadLinkService}
import fi.liikennevirasto.digiroad2.util.{Digiroad2Properties, KgvUtil, LinearAssetUtils}
import fi.liikennevirasto.digiroad2.{DummyEventBus, DummySerializer}
import org.joda.time.DateTime

import scala.collection.mutable.ListBuffer

class RoadLinkPropertyUpdater {

  lazy val roadLinkService: RoadLinkService = new RoadLinkService(new RoadLinkClient(Digiroad2Properties.vvhRestApiEndPoint), new DummyEventBus, new DummySerializer)
  lazy val roadLinkChangeClient: RoadLinkChangeClient = new RoadLinkChangeClient

  def withDynTransaction[T](f: => T): T = PostGISDatabase.withDynTransaction(f)

  def generateFunctionalClass(newLink: RoadLinkInfo): Boolean = {
    val featureClass = KgvUtil.extractFeatureClass(newLink.roadClass)
    val timeStamp = DateTime.now().toString()
    featureClass match {
      case FeatureClass.TractorRoad =>
        FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), 7, timeStamp)
        true
      case FeatureClass.HardShoulder =>
        FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), 9, timeStamp)
        true
      case FeatureClass.DrivePath | FeatureClass.CarRoad_IIIb =>
        FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), 6, timeStamp)
        true
      case FeatureClass.CycleOrPedestrianPath =>
        FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), 8, timeStamp)
        true
      case FeatureClass.SpecialTransportWithoutGate =>
        FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), UnknownFunctionalClass.value, timeStamp)
        true
      case FeatureClass.SpecialTransportWithGate =>
        FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), UnknownFunctionalClass.value, timeStamp)
        true
      case FeatureClass.CarRoad_IIIa => newLink.adminClass match {
        case State =>
          FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), 4, timeStamp)
          true
        case Municipality | Private =>
          FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), 5, timeStamp)
          true
        case _ => false
      }
      case _ => false
    }
  }

  def generateLinkType(newLink: RoadLinkInfo): Boolean = {
    val featureClass = KgvUtil.extractFeatureClass(newLink.roadClass)
    val timeStamp = DateTime.now().toString()
    featureClass match {
      case FeatureClass.TractorRoad =>
        LinkTypeDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), TractorRoad.value, timeStamp)
        true
      case FeatureClass.HardShoulder =>
        LinkTypeDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), HardShoulder.value, timeStamp)
        true
      case FeatureClass.DrivePath | FeatureClass.CarRoad_IIIb =>
        LinkTypeDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), SingleCarriageway.value, timeStamp)
        true
      case FeatureClass.CycleOrPedestrianPath =>
        LinkTypeDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), CycleOrPedestrianPath.value, timeStamp)
        true
      case FeatureClass.SpecialTransportWithoutGate =>
        LinkTypeDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), SpecialTransportWithoutGate.value, timeStamp)
        true
      case FeatureClass.SpecialTransportWithGate =>
        LinkTypeDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), SpecialTransportWithGate.value, timeStamp)
        true
      case FeatureClass.CarRoad_IIIa =>
        LinkTypeDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), SingleCarriageway.value, timeStamp)
        true
      case _ => false
    }
  }

  def incompleteLinkIsInUse(incompleteLink: IncompleteLink, roadLinkData: Seq[RoadLink]) = {
    val correspondingRoadLink = roadLinkData.find(_.linkId == incompleteLink.linkId)
    correspondingRoadLink match {
      case Some(roadLink) => roadLink.constructionType == InUse
      case _ => false
    }
  }

  def transferFunctionalClassAndLinkTypeFromOldLinks(optionalOldLink: Option[RoadLinkInfo], newLink: RoadLinkInfo): (Boolean, Boolean) = {
    val timeStamp = DateTime.now().toString()
    optionalOldLink match {
      case Some(oldLink) =>
        val optionalFunctionalClass = FunctionalClassDao.getExistingValue(oldLink.linkId)
        val optionalLinkType = LinkTypeDao.getExistingValue(oldLink.linkId)
        (optionalFunctionalClass, optionalLinkType) match {
          case (Some(functionalClass), Some(linkType)) =>
            FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), functionalClass, timeStamp)
            LinkTypeDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), linkType, timeStamp)
            (true, true)
          case (Some(functionalClass), None) =>
            FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), functionalClass, timeStamp)
            (true, false)
          case (None, Some(linkType)) =>
            LinkTypeDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), linkType, timeStamp)
            (false, true)
          case _ => (false, false)
          }
      case _ => (false, false)
    }
  }

  def transferOrGenerateFunctionalClassesAndLinkTypes(changes: Seq[RoadLinkChange]) = {
    val incompleteLinks = new ListBuffer[IncompleteLink]()
    changes.foreach { change =>
      change.newLinks foreach { newLink =>
        if (KgvUtil.extractFeatureClass(newLink.roadClass) != WinterRoads) {
          var (functionalClassCreated, linkTypeCreated) = transferFunctionalClassAndLinkTypeFromOldLinks(change.oldLink, newLink)
          if (!functionalClassCreated) {
            functionalClassCreated = generateFunctionalClass(newLink)
          }
          if (!linkTypeCreated) {
            linkTypeCreated = generateLinkType(newLink)
          }
          if (!(functionalClassCreated && linkTypeCreated)) {
            incompleteLinks += IncompleteLink(newLink.linkId, newLink.municipality, newLink.adminClass)
          }
        }
      }
    }
    val roadLinkData = roadLinkService.getRoadLinksByLinkIds(incompleteLinks.map(_.linkId).toSet, false)
    val incompleteLinksInUse = incompleteLinks.filter(il => incompleteLinkIsInUse(il, roadLinkData))
    roadLinkService.updateIncompleteLinks(incompleteLinksInUse)
  }

  def removePropertiesFromOldLinks(changes: Seq[RoadLinkChange]) = {
    changes.map(_.oldLink.get.linkId).foreach { linkId =>
      TrafficDirectionDao.deleteValues(linkId)
      LinkTypeDao.deleteValues(linkId)
      FunctionalClassDao.deleteValues(linkId)
      AdministrativeClassDao.expireValues(linkId, Some(AutoGeneratedUsername.automaticAdjustment), Some(LinearAssetUtils.createTimeStamp()))
      LinkAttributesDao.expireValues(linkId, Some(AutoGeneratedUsername.automaticAdjustment), Some(LinearAssetUtils.createTimeStamp()))
    }
  }

  def transferOverriddenPropertiesAndPrivateRoadInfo(changes: Seq[RoadLinkChange]) = {
    changes.foreach { change =>
      val oldLink = change.oldLink.get
      val optionalOverriddenTrafficDirection = TrafficDirectionDao.getExistingValue(oldLink.linkId)
      optionalOverriddenTrafficDirection match {
        case Some(overriddenTrafficDirection) =>
          change.newLinks.foreach { newLink =>
            if (overriddenTrafficDirection != newLink.trafficDirection.value) {
              RoadLinkOverrideDAO.insert(TrafficDirection, newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), overriddenTrafficDirection)
            }
          }
        case _ => //do nothing
      }

      val optionalOverriddenAdminClass = AdministrativeClassDao.getExistingValue(oldLink.linkId)
      optionalOverriddenAdminClass match {
        case Some(overriddenAdminClass) =>
          change.newLinks.foreach { newLink =>
            if (overriddenAdminClass != newLink.adminClass.value) {
              RoadLinkOverrideDAO.insert(AdministrativeClass, newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), overriddenAdminClass)
            }
          }
        case _ => //do nothing
      }

      val roadLinkAttributes = LinkAttributesDao.getExistingValues(oldLink.linkId)
      roadLinkAttributes.foreach { attribute =>
        change.newLinks.foreach { newLink =>
          LinkAttributesDao.insertAttributeValueByChanges(newLink.linkId, AutoGeneratedUsername.automaticGeneration, attribute._1, attribute._2, LinearAssetUtils.createTimeStamp())
        }
      }
    }
  }

  def updateProperties() = {
    val changes = roadLinkChangeClient.getRoadLinkChanges()
    val (addChanges, remaining) = changes.partition(_.changeType == Add)
    val (removeChanges, otherChanges) = remaining.partition(_.changeType == Remove)

    withDynTransaction {
      transferOverriddenPropertiesAndPrivateRoadInfo(otherChanges)
      transferOrGenerateFunctionalClassesAndLinkTypes(addChanges ++ otherChanges)
      removePropertiesFromOldLinks(removeChanges ++ otherChanges)
    }
  }
}
