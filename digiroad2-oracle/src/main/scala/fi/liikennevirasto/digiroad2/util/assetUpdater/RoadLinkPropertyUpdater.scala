package fi.liikennevirasto.digiroad2.util.assetUpdater

import fi.liikennevirasto.digiroad2.asset.ConstructionType.InUse
import fi.liikennevirasto.digiroad2.asset._
import fi.liikennevirasto.digiroad2.client.FeatureClass.WinterRoads
import fi.liikennevirasto.digiroad2.client.RoadLinkChangeType.{Add, Remove, Replace, Split}
import fi.liikennevirasto.digiroad2.client._
import fi.liikennevirasto.digiroad2.dao.RoadLinkOverrideDAO.{AdministrativeClass, TrafficDirection, _}
import fi.liikennevirasto.digiroad2.dao.{Queries, RoadLinkOverrideDAO}
import fi.liikennevirasto.digiroad2.linearasset.RoadLink
import fi.liikennevirasto.digiroad2.postgis.PostGISDatabase
import fi.liikennevirasto.digiroad2.service.{IncompleteLink, RoadLinkService}
import fi.liikennevirasto.digiroad2.util.assetUpdater.ChangeReporter.{generateCSV, saveReportToS3}
import fi.liikennevirasto.digiroad2.util.assetUpdater.ChangeTypeReport.{Creation, Deletion, Divided, Replaced}
import fi.liikennevirasto.digiroad2.util.{Digiroad2Properties, KgvUtil, LinearAssetUtils}
import fi.liikennevirasto.digiroad2.{DummyEventBus, DummySerializer}
import org.joda.time.DateTime

import scala.collection.mutable.ListBuffer

class RoadLinkPropertyUpdater {

  lazy val roadLinkService: RoadLinkService = new RoadLinkService(new RoadLinkClient(Digiroad2Properties.vvhRestApiEndPoint), new DummyEventBus, new DummySerializer)
  lazy val roadLinkChangeClient: RoadLinkChangeClient = new RoadLinkChangeClient

  def withDynTransaction[T](f: => T): T = PostGISDatabase.withDynTransaction(f)

  def roadLinkChangeToChangeType(roadLinkChangeType: RoadLinkChangeType): ChangeType = {
    roadLinkChangeType match {
      case Add => Creation
      case Remove => Deletion
      case Split => Divided
      case Replace => Replaced
    }
  }

  def generateFunctionalClass(changeType: RoadLinkChangeType, newLink: RoadLinkInfo): Option[FunctionalClassChange] = {
    val featureClass = KgvUtil.extractFeatureClass(newLink.roadClass)
    val timeStamp = DateTime.now().toString()
    featureClass match {
      case FeatureClass.TractorRoad =>
        FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), PrimitiveRoad.value, timeStamp)
        Some(FunctionalClassChange(newLink.linkId, roadLinkChangeToChangeType(changeType), None, Some(PrimitiveRoad.value), "mtkClass"))
      case FeatureClass.HardShoulder =>
        FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), FunctionalClass9.value, timeStamp)
        Some(FunctionalClassChange(newLink.linkId, roadLinkChangeToChangeType(changeType), None, Some(FunctionalClass9.value), "mtkClass"))
      case FeatureClass.DrivePath | FeatureClass.CarRoad_IIIb =>
        FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), AnotherPrivateRoad.value, timeStamp)
        Some(FunctionalClassChange(newLink.linkId, roadLinkChangeToChangeType(changeType), None, Some(AnotherPrivateRoad.value), "mtkClass"))
      case FeatureClass.CycleOrPedestrianPath =>
        FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), WalkingAndCyclingPath.value, timeStamp)
        Some(FunctionalClassChange(newLink.linkId, roadLinkChangeToChangeType(changeType), None, Some(WalkingAndCyclingPath.value), "mtkClass"))
      case FeatureClass.SpecialTransportWithoutGate =>
        FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), UnknownFunctionalClass.value, timeStamp)
        Some(FunctionalClassChange(newLink.linkId, roadLinkChangeToChangeType(changeType), None, Some(UnknownFunctionalClass.value), "mtkClass"))
      case FeatureClass.SpecialTransportWithGate =>
        FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), UnknownFunctionalClass.value, timeStamp)
        Some(FunctionalClassChange(newLink.linkId, roadLinkChangeToChangeType(changeType), None, Some(UnknownFunctionalClass.value), "mtkClass"))
      case FeatureClass.CarRoad_IIIa => newLink.adminClass match {
        case State =>
          FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), FunctionalClass4.value, timeStamp)
          Some(FunctionalClassChange(newLink.linkId, roadLinkChangeToChangeType(changeType), None, Some(FunctionalClass4.value), "mtkClass"))
        case Municipality | Private =>
          FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), FunctionalClass5.value, timeStamp)
          Some(FunctionalClassChange(newLink.linkId, roadLinkChangeToChangeType(changeType), None, Some(FunctionalClass5.value), "mtkClass"))
        case _ => None
      }
      case _ => None
    }
  }

  def generateLinkType(changeType: RoadLinkChangeType, newLink: RoadLinkInfo): Option[LinkTypeChange] = {
    val featureClass = KgvUtil.extractFeatureClass(newLink.roadClass)
    val timeStamp = DateTime.now().toString()
    featureClass match {
      case FeatureClass.TractorRoad =>
        LinkTypeDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), TractorRoad.value, timeStamp)
        Some(LinkTypeChange(newLink.linkId, roadLinkChangeToChangeType(changeType), None, Some(TractorRoad.value), "mtkClass"))
      case FeatureClass.HardShoulder =>
        LinkTypeDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), HardShoulder.value, timeStamp)
        Some(LinkTypeChange(newLink.linkId, roadLinkChangeToChangeType(changeType), None, Some(HardShoulder.value), "mtkClass"))
      case FeatureClass.DrivePath | FeatureClass.CarRoad_IIIb =>
        LinkTypeDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), SingleCarriageway.value, timeStamp)
        Some(LinkTypeChange(newLink.linkId, roadLinkChangeToChangeType(changeType), None, Some(SingleCarriageway.value), "mtkClass"))
      case FeatureClass.CycleOrPedestrianPath =>
        LinkTypeDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), CycleOrPedestrianPath.value, timeStamp)
        Some(LinkTypeChange(newLink.linkId, roadLinkChangeToChangeType(changeType), None, Some(CycleOrPedestrianPath.value), "mtkClass"))
      case FeatureClass.SpecialTransportWithoutGate =>
        LinkTypeDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), SpecialTransportWithoutGate.value, timeStamp)
        Some(LinkTypeChange(newLink.linkId, roadLinkChangeToChangeType(changeType), None, Some(SpecialTransportWithoutGate.value), "mtkClass"))
      case FeatureClass.SpecialTransportWithGate =>
        LinkTypeDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), SpecialTransportWithGate.value, timeStamp)
        Some(LinkTypeChange(newLink.linkId, roadLinkChangeToChangeType(changeType), None, Some(SpecialTransportWithGate.value), "mtkClass"))
      case FeatureClass.CarRoad_IIIa =>
        LinkTypeDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), SingleCarriageway.value, timeStamp)
        Some(LinkTypeChange(newLink.linkId, roadLinkChangeToChangeType(changeType), None, Some(SingleCarriageway.value), "mtkClass"))
      case _ => None
    }
  }

  def incompleteLinkIsInUse(incompleteLink: IncompleteLink, roadLinkData: Seq[RoadLink]) = {
    val correspondingRoadLink = roadLinkData.find(_.linkId == incompleteLink.linkId)
    correspondingRoadLink match {
      case Some(roadLink) => roadLink.constructionType == InUse
      case _ => false
    }
  }

  def transferFunctionalClassAndLinkTypeFromOldLinks(changeType: RoadLinkChangeType, optionalOldLink: Option[RoadLinkInfo], newLink: RoadLinkInfo): (Option[FunctionalClassChange], Option[LinkTypeChange]) = {
    val timeStamp = DateTime.now().toString()
    optionalOldLink match {
      case Some(oldLink) =>
        val optionalFunctionalClass = FunctionalClassDao.getExistingValue(oldLink.linkId)
        val optionalLinkType = LinkTypeDao.getExistingValue(oldLink.linkId)
        (optionalFunctionalClass, optionalLinkType) match {
          case (Some(functionalClass), Some(linkType)) =>
            FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), functionalClass, timeStamp)
            LinkTypeDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), linkType, timeStamp)
            (Some(FunctionalClassChange(newLink.linkId, roadLinkChangeToChangeType(changeType), Some(functionalClass), Some(functionalClass), "oldLink")),
              Some(LinkTypeChange(newLink.linkId, roadLinkChangeToChangeType(changeType), Some(linkType), Some(linkType), "oldLink")))
          case (Some(functionalClass), None) =>
            FunctionalClassDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), functionalClass, timeStamp)
            (Some(FunctionalClassChange(newLink.linkId, roadLinkChangeToChangeType(changeType), Some(functionalClass), Some(functionalClass), "oldLink")), None)
          case (None, Some(linkType)) =>
            LinkTypeDao.insertValues(newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), linkType, timeStamp)
            (None, Some(LinkTypeChange(newLink.linkId, roadLinkChangeToChangeType(changeType), Some(linkType), Some(linkType), "oldLink")))
          case _ => (None, None)
          }
      case _ => (None, None)
    }
  }

  def transferOrGenerateFunctionalClassesAndLinkTypes(changes: Seq[RoadLinkChange]) = {
    val incompleteLinks = new ListBuffer[IncompleteLink]()
    val createdProperties = new ListBuffer[Option[ReportedChange]]()
    changes.foreach { change =>
      change.newLinks foreach { newLink =>
        if (KgvUtil.extractFeatureClass(newLink.roadClass) != WinterRoads) {
          var (functionalClassChange, linkTypeChange) = transferFunctionalClassAndLinkTypeFromOldLinks(change.changeType, change.oldLink, newLink)
          if (functionalClassChange.isEmpty) {
            functionalClassChange = generateFunctionalClass(change.changeType, newLink)
          }
          if (linkTypeChange.isEmpty) {
            linkTypeChange = generateLinkType(change.changeType, newLink)
          }
          if (functionalClassChange.isEmpty || linkTypeChange.isEmpty) {
            incompleteLinks += IncompleteLink(newLink.linkId, newLink.municipality, newLink.adminClass)
          }
          createdProperties += functionalClassChange
          createdProperties += linkTypeChange
        }
      }
    }
    val roadLinkData = roadLinkService.getRoadLinksByLinkIds(incompleteLinks.map(_.linkId).toSet, false)
    val incompleteLinksInUse = incompleteLinks.filter(il => incompleteLinkIsInUse(il, roadLinkData))
    roadLinkService.updateIncompleteLinks(incompleteLinksInUse)
    createdProperties.flatten
  }

  def removePropertiesFromOldLinks(changes: Seq[RoadLinkChange]) = {
    val groupedChanges = changes.groupBy(_.oldLink.get.linkId)
    val oldLinkIds = changes.map(_.oldLink.get.linkId)
    val deletedTrafficDirections = TrafficDirectionDao.getExistingValues(oldLinkIds).map(deletion =>
      TrafficDirectionChange(deletion.linkId, roadLinkChangeToChangeType(groupedChanges(deletion.linkId).head.changeType), deletion.value.get, None))
    val deletedAdministrativeClasses = AdministrativeClassDao.getExistingValues(oldLinkIds).map(deletion =>
      AdministrativeClassChange(deletion.linkId, roadLinkChangeToChangeType(groupedChanges(deletion.linkId).head.changeType), deletion.value.get, None))
    val deletedFunctionalClasses = FunctionalClassDao.getExistingValues(oldLinkIds).map(deletion =>
      FunctionalClassChange(deletion.linkId, roadLinkChangeToChangeType(groupedChanges(deletion.linkId).head.changeType), deletion.value, None))
    val deletedLinkTypes = LinkTypeDao.getExistingValues(oldLinkIds).map(deletion =>
      LinkTypeChange(deletion.linkId, roadLinkChangeToChangeType(groupedChanges(deletion.linkId).head.changeType), deletion.value, None))
    val deletedAttributes = oldLinkIds.map(linkId => {
      val oldAttributes = LinkAttributesDao.getExistingValues(linkId)
      RoadLinkAttributeChange(linkId, roadLinkChangeToChangeType(groupedChanges(linkId).head.changeType), oldAttributes, Map())
    })
    val deletedProperties: Seq[ReportedChange] = deletedTrafficDirections ++ deletedAdministrativeClasses ++ deletedFunctionalClasses ++ deletedLinkTypes ++ deletedAttributes

    oldLinkIds.foreach { linkId =>
      TrafficDirectionDao.deleteValues(linkId)
      LinkTypeDao.deleteValues(linkId)
      FunctionalClassDao.deleteValues(linkId)
      AdministrativeClassDao.expireValues(linkId, Some(AutoGeneratedUsername.automaticAdjustment), Some(LinearAssetUtils.createTimeStamp()))
      LinkAttributesDao.expireValues(linkId, Some(AutoGeneratedUsername.automaticAdjustment), Some(LinearAssetUtils.createTimeStamp()))
    }
    deletedProperties
  }

  def transferOverriddenPropertiesAndPrivateRoadInfo(changes: Seq[RoadLinkChange]) = {
    val transferredProperties = ListBuffer[ReportedChange]()
    changes.foreach { change =>
      val oldLink = change.oldLink.get
      val optionalOverriddenTrafficDirection = TrafficDirectionDao.getExistingValue(oldLink.linkId)
      optionalOverriddenTrafficDirection match {
        case Some(overriddenTrafficDirection) =>
          change.newLinks.foreach { newLink =>
            if (overriddenTrafficDirection != newLink.trafficDirection.value) {
              RoadLinkOverrideDAO.insert(TrafficDirection, newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), overriddenTrafficDirection)
              transferredProperties += TrafficDirectionChange(newLink.linkId, roadLinkChangeToChangeType(change.changeType), overriddenTrafficDirection, Some(overriddenTrafficDirection))
            }
          }
        case _ => //do nothing
      }

      val optionalOverriddenAdminClass = AdministrativeClassDao.getExistingValue(oldLink.linkId)
      optionalOverriddenAdminClass match {
        case Some(overriddenAdminClass) =>
          change.newLinks.foreach { newLink =>
            if (overriddenAdminClass != newLink.adminClass.value) {
              RoadLinkOverrideDAO.insert(AdministrativeClass, newLink.linkId, Some(AutoGeneratedUsername.automaticGeneration), overriddenAdminClass)
              transferredProperties += AdministrativeClassChange(newLink.linkId, roadLinkChangeToChangeType(change.changeType), overriddenAdminClass, Some(overriddenAdminClass))
            }
          }
        case _ => //do nothing
      }

      val roadLinkAttributes = LinkAttributesDao.getExistingValues(oldLink.linkId)
      if (roadLinkAttributes.nonEmpty) {
        change.newLinks.foreach { newLink =>
          roadLinkAttributes.foreach { attribute =>
            LinkAttributesDao.insertAttributeValueByChanges(newLink.linkId, AutoGeneratedUsername.automaticGeneration, attribute._1, attribute._2, LinearAssetUtils.createTimeStamp())
          }
          transferredProperties += RoadLinkAttributeChange(newLink.linkId, roadLinkChangeToChangeType(change.changeType), roadLinkAttributes, roadLinkAttributes)
        }
      }
    }
    transferredProperties
  }

  def updateProperties() = {
    withDynTransaction {
      val latestSuccess = Queries.getLatestSuccessfulSamuutus(RoadLinkProperties.typeId)
      val changes = roadLinkChangeClient.getRoadLinkChanges(latestSuccess)
      val (addChanges, remaining) = changes.partition(_.changeType == Add)
      val (removeChanges, otherChanges) = remaining.partition(_.changeType == Remove)

      val transferredProperties = transferOverriddenPropertiesAndPrivateRoadInfo(otherChanges)
      val createdProperties = transferOrGenerateFunctionalClassesAndLinkTypes(addChanges ++ otherChanges)
      val deletedProperties = removePropertiesFromOldLinks(removeChanges ++ otherChanges)
      val changeReport = ChangeReport(RoadLinkProperties.typeId, transferredProperties ++ createdProperties ++ deletedProperties)
      val (reportBody, contentRowCount) = generateCSV(changeReport)
      saveReportToS3("roadLinkProperties", reportBody, contentRowCount)
      Queries.updateLatestSuccessfulSamuutus(RoadLinkProperties.typeId)
    }
  }
}
