package fi.liikennevirasto.digiroad2.util

import fi.liikennevirasto.digiroad2.asset.SideCode
import fi.liikennevirasto.digiroad2.{DummyEventBus, DummySerializer}
import fi.liikennevirasto.digiroad2.client.viite.{ChangeInformation, IntegrationViiteClient, Source}
import fi.liikennevirasto.digiroad2.client.vvh.VVHClient
import fi.liikennevirasto.digiroad2.lane.LaneNumber.MainLane
import fi.liikennevirasto.digiroad2.lane.{LaneNumber, LaneProperty, LanePropertyValue, NewIncomeLane}
import fi.liikennevirasto.digiroad2.postgis.PostGISDatabase
import fi.liikennevirasto.digiroad2.service.RoadLinkService
import fi.liikennevirasto.digiroad2.service.lane.LaneService
import org.apache.http.impl.client.HttpClientBuilder
import org.joda.time.DateTime

object AutomaticLaneCreationModificationProcess {
  def withDynTransaction[T](f: => T): T = PostGISDatabase.withDynTransaction(f)

  lazy val integrationViiteClient: IntegrationViiteClient = {
    new IntegrationViiteClient(Digiroad2Properties.viiteRestApiEndPoint, HttpClientBuilder.create().build())
  }

  lazy val vvhClient: VVHClient = {
    new VVHClient(Digiroad2Properties.vvhRestApiEndPoint)
  }

  lazy val roadLinkService: RoadLinkService = {
    new RoadLinkService(vvhClient, new DummyEventBus, new DummySerializer)
  }
  
  lazy val laneService: LaneService = {
    new LaneService(roadLinkService,new DummyEventBus)
  }
  
  lazy val user="autogenerated_lane"

  // change type 2
  private def newLane(changeInfo: ChangeInformation): Seq[Long] = {

    if (changeInfo.changeType == 2) {
      val source = changeInfo.oldRoadNumbering
      val maintenanceHole = Seq(30000, 39999)
      val pedestrianAndCycleRoute = Seq(70000, 99999)
      val path = Seq(62000, 62999)

      def mapPropertiesDefaultValue(source: Source, laneCode: Int, lanetype: Int = 1): Seq[LaneProperty] = {
        Seq(
          LaneProperty("lane_type", Seq(LanePropertyValue(value = lanetype))),
          LaneProperty("lane_code", Seq(LanePropertyValue(value = laneCode))),
          LaneProperty("roadNumber", Seq(LanePropertyValue(value = source.roadNumber))),
          LaneProperty("roadPartNumber", Seq(LanePropertyValue(value = source.roadPartNumber))),
          LaneProperty("track", Seq(LanePropertyValue(value = source.track))),
          LaneProperty("startAddrMValue", Seq(LanePropertyValue(value = source.startAddrMValue))),
          LaneProperty("endAddrMValue", Seq(LanePropertyValue(value = source.endAddrMValue))),
          LaneProperty("administrativeClass", Seq(LanePropertyValue(value = source.administrativeValues)))
        )
      }

      def checkRange(number: Int, range: Seq[Int]): Boolean = {
        (range.head to range.last).contains(number)
      }

      def laneCodeAndSideCode(source: Source): (Option[Int], Option[ Int]) = {

        val (track, roadNumber, roadPartNumber) = (source.track, source.roadNumber, source.roadPartNumber)

        // roadNumbers 70000 - 99999: Lane Code 31
        // roadNumbers 62000 - 62999: Lane Code 31
        val pedestrianAndCycleRouteAndPathCheck = (checkRange(roadNumber.toInt, path) ||
          checkRange(roadNumber.toInt, pedestrianAndCycleRoute))

        // roadNumbers 30000-39999 roadPartNumber 9 Lane Code 31
        val maintenanceHoleCheck = checkRange(roadNumber.toInt, maintenanceHole) && roadPartNumber == 9

        //Track 0, roadNumbers 20000 - 29999, roadPartNumbers 995-999: Lane Code 31
        val checkMotorwayMaintenance = (track.value == 0 &&
          checkRange(roadNumber.toInt, Seq(20000, 29999)) &&
          checkRange(roadPartNumber.toInt, Seq(995, 999)))

        //Track 2: Lane Code 21
        if (track.value == 2) {
          (Some(MainLane.againstDirection), Some(SideCode(2).value))
        } else if (pedestrianAndCycleRouteAndPathCheck || maintenanceHoleCheck || checkMotorwayMaintenance) {
          (Some(MainLane.motorwayMaintenance), Some(SideCode(3).value))
        } else if (track.value == 1 || (track.value == 0 && checkRange(roadNumber.toInt, Seq(20000, 39999)))) {
          //Track 1: Lane Code 11
          //Track 0, roadNumbers 20000 - 39999: Lane Code 11
          (Some(MainLane.towardsDirection), Some(SideCode(1).value))
        }else{
          (None,None)
        }
      }

      // TODO get set(linkIds) from vkm by  tieosoite, 
      // TODO get MValues of links from VKM
      // check if there is already lane in part of section
      val laneExist = false
      val startMeasureFromVKM = 0
      val endMeasureFromVKM = 0
      if (laneExist) {
        // new lane to empty road
        val newLaneProperties = if (checkRange(source.roadNumber.toInt, pedestrianAndCycleRoute)) {
          mapPropertiesDefaultValue(source, laneCodeAndSideCode(source)._1.get, 20)
        } else {
          mapPropertiesDefaultValue(source, laneCodeAndSideCode(source)._1.get)
        }

        //Track(Ajorata) 0, roadNumbers(tiet) 1-19999 ja 40000 - 61999: Lane Code (Kaistat) 11 ja 21
        if (source.track.value == 0 && (checkRange(source.roadNumber.toInt, Seq(1, 19999))
          || checkRange(source.roadNumber.toInt, Seq(40000, 61999)))) {
          val newLanes = Seq(
            NewIncomeLane(0, startMeasure = startMeasureFromVKM,
              endMeasure = endMeasureFromVKM, 0, properties = mapPropertiesDefaultValue(source, 11), sideCode = Some(1)),
            NewIncomeLane(0, startMeasure = startMeasureFromVKM,
              endMeasure = endMeasureFromVKM, 0, properties = mapPropertiesDefaultValue(source, 21), sideCode =  Some(2)))
          laneService.createNewFromChange(newLanes, Set(0, 1, 2, 3), user)
        } else {
          val newLane = Seq(NewIncomeLane(0, startMeasure = startMeasureFromVKM,
            endMeasure = endMeasureFromVKM, 0, properties = newLaneProperties, sideCode =  Some(laneCodeAndSideCode(source)._2.get)))
          laneService.createNewFromChange(newLane, Set(0, 1, 2, 3), user)
        }
      } else {
        // continue old lane to new part

        // get lane by linkId

        // copy old lane info and add to new section
      }
    }

    throw new NotImplementedError()
  }
  // change type 3
  private def transferLane(changeInfo:ChangeInformation):Long = {
    throw new NotImplementedError()
  }
  // change type 4
  private def renumbering(changeInfo:ChangeInformation):Long = {
    throw new NotImplementedError()
  }
  // change type 5
  private def expiringLane(changeInfo:ChangeInformation):Long= {
    throw new NotImplementedError()
  }

  def process() = {
    val changeInformations = integrationViiteClient.fetchRoadwayChangesChanges(new DateTime().minusDays(1))
    
    if(changeInformations.isDefined){
      withDynTransaction {
        changeInformations.foreach(change=>{
          // add operation
        })
      }
    }
  }

}
