package fi.liikennevirasto.digiroad2.util

import fi.liikennevirasto.digiroad2.{DummyEventBus, DummySerializer}
import fi.liikennevirasto.digiroad2.client.viite.{ChangeInformation, IntegrationViiteClient, Source}
import fi.liikennevirasto.digiroad2.client.vvh.VVHClient
import fi.liikennevirasto.digiroad2.lane.LaneNumber.MainLane
import fi.liikennevirasto.digiroad2.lane.{ LaneProperty, LanePropertyValue, NewIncomeLane}
import fi.liikennevirasto.digiroad2.postgis.PostGISDatabase
import fi.liikennevirasto.digiroad2.service.RoadLinkService
import fi.liikennevirasto.digiroad2.service.lane.LaneService
import org.apache.http.impl.client.HttpClientBuilder
import org.joda.time.DateTime

object AutomaticLaneCreationModificationProcess {
  def withDynTransaction[T](f: => T): T = PostGISDatabase.withDynTransaction(f)

  lazy val integrationViiteClient: IntegrationViiteClient = {
    new IntegrationViiteClient(Digiroad2Properties.viiteRestApiEndPoint, HttpClientBuilder.create().build())
  }

  lazy val vvhClient: VVHClient = {
    new VVHClient(Digiroad2Properties.vvhRestApiEndPoint)
  }

  lazy val roadLinkService: RoadLinkService = {
    new RoadLinkService(vvhClient, new DummyEventBus, new DummySerializer)
  }
  
  lazy val laneService: LaneService = {
    new LaneService(roadLinkService,new DummyEventBus)
  }
  
  lazy val user="autogenerated_lane"

  // change type 2
  private def newLane(changeInfo: ChangeInformation): Seq[Long] = {
   
    if (changeInfo.changeType == 2) {
      val source = changeInfo.oldRoadNumbering
      val maintenanceHole = Seq(30000, 39999)
      val pedestrianAndCycleRoute = Seq(70000, 99999)
      val path = Seq(62000, 62999)

      def mapPropertiesDefaultValue(source: Source, laneCode: Int, lanetype: Int = 1): Seq[LaneProperty] = {
        Seq(
          LaneProperty("lane_type", Seq(LanePropertyValue(value = lanetype))),
          LaneProperty("lane_code", Seq(LanePropertyValue(value = laneCode))),
          LaneProperty("roadNumber", Seq(LanePropertyValue(value = source.roadNumber))),
          LaneProperty("roadPartNumber", Seq(LanePropertyValue(value = source.roadPartNumber))),
          LaneProperty("track", Seq(LanePropertyValue(value = source.track))),
          LaneProperty("startAddrMValue", Seq(LanePropertyValue(value = source.startAddrMValue))),
          LaneProperty("endAddrMValue", Seq(LanePropertyValue(value = source.endAddrMValue))),
          LaneProperty("administrativeClass", Seq(LanePropertyValue(value = source.administrativeValues)))
        )
      }

      def checkRange(number: Int, range: Seq[Int]): Boolean = {
        (range.head to range.last).contains(number)
      }

      def laneCode(source: Source): Int = {

        val (track, roadNumber, roadPartNumber) = (source.track, source.roadNumber, source.roadPartNumber)

        //Kevarit (roadNumbers(tie) 70000 - 99999): Lane Code (Kaistat) 31
        //Polut (roadNumbers(tie) 62000 - 62999): Lane Code (Kaistat) 31
        val pedestrianAndCycleRouteAndPathCheck = (checkRange(roadNumber.toInt, path) ||
          checkRange(roadNumber.toInt, pedestrianAndCycleRoute))

        //Huoltoaukot (roadNumbers(tie) 30000-39999 roadPartNumber(osa) 9) Lane Code (Kaistat) 31
        val maintenanceHoleCheck = checkRange(roadNumber.toInt, maintenanceHole) && roadPartNumber == 9

        //Track(Ajorata) 0, tiet 20000 - 29999, tieosa 995-999: Lane Code (Kaistat) 31
        val checkMotorwayMaintenance3 = (track.value == 0 &&
          checkRange(roadNumber.toInt, Seq(20000, 29999)) &&
          checkRange(roadPartNumber.toInt, Seq(995, 999)))
        
        //Track(Ajorata) 2: Lane Code (Kaistat) 21
        if (track.value == 2) {
          MainLane.againstDirection
        } else if (pedestrianAndCycleRouteAndPathCheck || maintenanceHoleCheck || checkMotorwayMaintenance3) {
          MainLane.motorwayMaintenance
        }else if (track.value == 1 || (track.value == 0 && checkRange(roadNumber.toInt, Seq(20000, 39999)))) {
          //Track(Ajorata) 1: Lane Code (Kaistat) 11
          //Track(Ajorata) 0, roadNumbers(tiet) 20000 - 39999: Lane Code (Kaistat) 11
          MainLane.towardsDirection
        }
      }

      // get set(linkIds) from vkm by  tieosoite
      val laneExist = false
      if (laneExist) {
        // new lane to empty road
        val newLaneProperties = if (checkRange(source.roadNumber.toInt, pedestrianAndCycleRoute)) {
          mapPropertiesDefaultValue(source, laneCode(source), 20)
        } else {
          mapPropertiesDefaultValue(source, laneCode(source))
        }

        //Track(Ajorata) 0, roadNumbers(tiet) 1-19999 ja 40000 - 61999: Lane Code (Kaistat) 11 ja 21 ?
        if (source.track.value == 0 && (checkRange(source.roadNumber.toInt, Seq(1, 19999)) || checkRange(source.roadNumber.toInt, Seq(40000, 61999)))) {
          val newLanes = Seq(
            NewIncomeLane(0, startMeasure = source.startAddrMValue,
              endMeasure = source.endAddrMValue, 0, isExpired = false, isDeleted = false, mapPropertiesDefaultValue(source, 11)),
            NewIncomeLane(0, startMeasure = source.startAddrMValue,
              endMeasure = source.endAddrMValue, 0, isExpired = false, isDeleted = false, mapPropertiesDefaultValue(source, 21)))
          laneService.create(newLanes, Set(0, 1, 2, 3), 0, user)
        } else {
          val newLane = Seq(NewIncomeLane(0, startMeasure = source.startAddrMValue,
            endMeasure = source.endAddrMValue, 0, isExpired = false, isDeleted = false, newLaneProperties))
          laneService.create(newLane, Set(0, 1, 2, 3), 0, user)
        }
      } else {
        // continue old lane to new part

        // check if there is already lane in part of section 

        // get lane by linkId

        // copy old lane info and add to new section
      }
    }

    throw new NotImplementedError()
  }
  // change type 3
  private def transferLane(changeInfo:ChangeInformation):Long = {
    throw new NotImplementedError()
  }
  // change type 4
  private def renumbering(changeInfo:ChangeInformation):Long = {
    throw new NotImplementedError()
  }
  // change type 5
  private def expiringLane(changeInfo:ChangeInformation):Long= {
    throw new NotImplementedError()
  }

  def process() = {
    val changeInformations = integrationViiteClient.fetchRoadwayChangesChanges(new DateTime().minusDays(1))
    
    if(changeInformations.isDefined){
      withDynTransaction {
        changeInformations.foreach(change=>{
          // add operation
        })
      }
    }
  }

}
