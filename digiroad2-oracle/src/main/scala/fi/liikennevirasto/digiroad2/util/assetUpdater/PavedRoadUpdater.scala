package fi.liikennevirasto.digiroad2.util.assetUpdater

import fi.liikennevirasto.digiroad2.GeometryUtils
import fi.liikennevirasto.digiroad2.asset.{AutoGeneratedUsername, DynamicProperty, DynamicPropertyValue, LinkGeomSource, MmlNls, PavedRoad, SideCode, UnknownLinkType}
import fi.liikennevirasto.digiroad2.client.{RoadLinkChange, RoadLinkChangeType}
import fi.liikennevirasto.digiroad2.client.vvh.ChangeInfo
import fi.liikennevirasto.digiroad2.dao.RoadLinkOverrideDAO.FunctionalClassDao
import fi.liikennevirasto.digiroad2.linearasset.LinearAssetFiller._
import fi.liikennevirasto.digiroad2.linearasset.{DynamicAssetValue, DynamicValue, LinearAssetFiller, NumericValue, PersistedLinearAsset, RoadLink}
import fi.liikennevirasto.digiroad2.service.linearasset.LinearAssetTypes
import fi.liikennevirasto.digiroad2.service.pointasset.PavedRoadService
import fi.liikennevirasto.digiroad2.util.LinearAssetUtils
import org.joda.time.DateTime

class PavedRoadUpdater(service: PavedRoadService) extends DynamicLinearAssetUpdater(service) {
  
  override def operationForNewLink(change: RoadLinkChange, assetsAll: Seq[PersistedLinearAsset], changeSets: ChangeSet): Option[OperationStep] = {
    
    val roadLink = roadLinkService.getRoadLinksAndComplementariesByLinkIds(Set(change.newLinks.head.linkId), newTransaction = false).head
    
    if(roadLink.isPaved) {

      val defaultMultiTypePropSeq = DynamicAssetValue(Seq(DynamicProperty("paallysteluokka", "single_choice", required = false, Seq(DynamicPropertyValue("99")))))
      val defaultPropertyData = DynamicValue(defaultMultiTypePropSeq)
      
      val newAsset = PersistedLinearAsset(0, change.newLinks.head.linkId, 
        sideCode = SideCode.BothDirections.value,
        value = Some(defaultPropertyData),
        startMeasure = 0, endMeasure = GeometryUtils.geometryLength(change.newLinks.head.geometry), createdBy = None,
        createdDateTime = Some(DateTime.now()),
        modifiedBy = None, modifiedDateTime = None, expired = false, 
        typeId = LinearAssetTypes.PavedRoadAssetTypeId,
        timeStamp = LinearAssetUtils.createTimeStamp(), geomModifiedDate = Some(DateTime.now())
        , linkSource = LinkGeomSource.NormalLinkInterface, 
        verifiedBy =None, verifiedDate = None,
        informationSource = Some(MmlNls))
      Some(OperationStep(Seq(newAsset), Some(changeSets)))
    }else {
      None
    }
    
  }


  override def additionalUpdateOrChange(change: RoadLinkChange, assetsAll: Seq[PersistedLinearAsset], changeSets: ChangeSet): Option[OperationStep] = {
    change.changeType match {
     //remove pavement
      case RoadLinkChangeType.Replace | RoadLinkChangeType.Split =>
        val newLinksMapped = change.newLinks.map(_.linkId)
        val expiredPavement = assetsAll.filter(a => newLinksMapped.contains(a.linkId)).map(asset => {
          val replace = newLinksMapped.find(_ == asset.linkId).get
          val roadLink = roadLinkService.getRoadLinksAndComplementariesByLinkIds(Set(replace), newTransaction = false).head
          if (roadLink.isNotPaved) {
            if (asset.id !=0){
              OperationStep(Seq(asset),
                Some(changeSets.copy(
                  expiredAssetIds = changeSets.expiredAssetIds ++ Set(asset.id),
                  replacedAssetIds = changeSets.replacedAssetIds ++ Set(asset.id)
                )))
            } else {
              OperationStep(Seq(asset.copy(id = removePart)), Some(changeSets))
            }
          } else {
            OperationStep(Seq(asset), Some(changeSets))
          }
        }).foldLeft(OperationStep(assetsAll,Some(changeSets)))((a, b) => {
          OperationStep(a.assets ++ b.assets, Some(LinearAssetFiller.combineChangeSets(a.changeInfo.get, b.changeInfo.get)))
        })
        Some(expiredPavement)
      case _ => None
    }
  }

  override def filterChanges(changes: Seq[RoadLinkChange]): Seq[RoadLinkChange] = {
    val (remove, other) = changes.partition(_.changeType == RoadLinkChangeType.Remove)
    val linksOther = other.flatMap(_.newLinks.map(_.linkId)).toSet
    val filterChanges = if (linksOther.nonEmpty) {
      val links = roadLinkService.getRoadLinksAndComplementariesByLinkIds(linksOther,false)
      val filteredLinks = links.filter(_.functionalClass > 4).map(_.linkId)
      other.filter(p => filteredLinks.contains(p.newLinks.head.linkId))
    } else Seq()
    filterChanges ++ remove
  }

}
