package fi.liikennevirasto.digiroad2.util.assetUpdater

import fi.liikennevirasto.digiroad2.GeometryUtils
import fi.liikennevirasto.digiroad2.asset.TrafficDirection.toSideCode
import fi.liikennevirasto.digiroad2.asset._
import fi.liikennevirasto.digiroad2.client.RoadLinkChange
import fi.liikennevirasto.digiroad2.client.RoadLinkChangeType.{Replace, Split}
import fi.liikennevirasto.digiroad2.linearasset.LinearAssetFiller._
import fi.liikennevirasto.digiroad2.linearasset.SurfaceType.Paved
import fi.liikennevirasto.digiroad2.linearasset._
import fi.liikennevirasto.digiroad2.service.linearasset.{LinearAssetTypes, Measures}
import fi.liikennevirasto.digiroad2.service.pointasset.PavedRoadService
import fi.liikennevirasto.digiroad2.util.{LinearAssetUtils, LogUtils}
import org.joda.time.DateTime

class PavedRoadUpdater(service: PavedRoadService) extends DynamicLinearAssetUpdater(service) {

  override def operationForNewLink(change: RoadLinkChange, assetsAll: Seq[PersistedLinearAsset], onlyNeededNewRoadLinks: Seq[RoadLink], changeSets: ChangeSet): Option[OperationStep] = {
    val newLinkInfo = change.newLinks.head
    val roadLinkFound = onlyNeededNewRoadLinks.exists(_.linkId == newLinkInfo.linkId)

    if (newLinkInfo.surfaceType == SurfaceType.Paved && roadLinkFound) {
      val defaultMultiTypePropSeq = DynamicAssetValue(Seq(DynamicProperty("paallysteluokka", "single_choice", required = false, Seq(DynamicPropertyValue("99")))))
      val defaultPropertyData = DynamicValue(defaultMultiTypePropSeq)
      
      val newAsset = PersistedLinearAsset(0, newLinkInfo.linkId,
        sideCode = SideCode.BothDirections.value,
        value = Some(defaultPropertyData),
        startMeasure = 0, endMeasure = GeometryUtils.geometryLength(newLinkInfo.geometry), createdBy = Some(AutoGeneratedUsername.mmlPavedDefault),
        createdDateTime = Some(DateTime.now()),
        modifiedBy = None, modifiedDateTime = None, expired = false, 
        typeId = LinearAssetTypes.PavedRoadAssetTypeId,
        timeStamp = LinearAssetUtils.createTimeStamp(), geomModifiedDate = Some(DateTime.now()),
        linkSource = LinkGeomSource.NormalLinkInterface,
        verifiedBy = None, verifiedDate = None,
        informationSource = Some(MmlNls))
      Some(OperationStep(Seq(newAsset), Some(changeSets),Seq()))
    } else {
      None
    }
    
  }

  private def generateNewPavementForSplitAndReplace(operationStep: OperationStep, changes: Seq[RoadLinkChange]) = {
    val assetsAll: Seq[PersistedLinearAsset] = operationStep.assetsAfter
    val newLinksWithPavedSurfaceType = changes.filter(c => c.changeType == Replace || c.changeType == Split).flatMap(_.newLinks)
      .filter(link => link.surfaceType == Paved)
    val newLinksLackingPavement = newLinksWithPavedSurfaceType.filterNot(link => assetsAll.map(_.linkId).contains(link.linkId)).distinct

    val newAssets = newLinksLackingPavement.map{newLinkInfo =>
      val relevantChange = changes.find(c => c.newLinks.nonEmpty && c.newLinks.map(_.linkId).contains(newLinkInfo.linkId)).get
      val defaultMultiTypePropSeq = DynamicAssetValue(Seq(DynamicProperty("paallysteluokka", "single_choice", required = false, Seq(DynamicPropertyValue("99")))))
      val defaultPropertyData = DynamicValue(defaultMultiTypePropSeq)

      val newAsset = PersistedLinearAsset(0, newLinkInfo.linkId,
        sideCode = toSideCode(newLinkInfo.trafficDirection).value,
        value = Some(defaultPropertyData),
        startMeasure = 0, endMeasure = newLinkInfo.linkLength, createdBy = Some(AutoGeneratedUsername.mmlPavedDefault),
        createdDateTime = Some(DateTime.now()),
        modifiedBy = None, modifiedDateTime = None, expired = false,
        typeId = LinearAssetTypes.PavedRoadAssetTypeId,
        timeStamp = LinearAssetUtils.createTimeStamp(), geomModifiedDate = Some(DateTime.now()),
        linkSource = LinkGeomSource.NormalLinkInterface,
        verifiedBy = None, verifiedDate = None,
        informationSource = Some(MmlNls)
      )
      reportAssetChanges(None, Some(newAsset), Seq(relevantChange), OperationStep(Seq(newAsset), operationStep.changeInfo, Seq()), Some(ChangeTypeReport.Creation), true)
      newAsset
    }
    OperationStep(operationStep.assetsAfter ++ newAssets, operationStep.changeInfo, operationStep.assetsBefore)
  }

  override def additionalOperations(operationStep: OperationStep, changes: Seq[RoadLinkChange], allAssetsBefore: Seq[PersistedLinearAsset]): Option[OperationStep] = {
    val operationAfterGeneration = generateNewPavementForSplitAndReplace(operationStep, changes)
    val (assetsToBeRemoved, assetsToPersist) = collectRemovablePavementAssets(operationAfterGeneration, changes)
    removePavement(assetsToBeRemoved, assetsToPersist, operationAfterGeneration, changes, allAssetsBefore)
  }

  /**
   * Check if pavedRoad asset is generated from MML information, and not modified, or only modified by samuutus
   *
   * @param asset
   * @return True if generated from MML info and not modified by user or batch, else false
   */
  private def isGeneratedFromMML(asset: PersistedLinearAsset): Boolean = {
    val createdBy = asset.createdBy.getOrElse("")
    val modifiedBy = asset.modifiedBy.getOrElse("")

    val generatedFromMML = createdBy == AutoGeneratedUsername.generatedInUpdate || createdBy == AutoGeneratedUsername.mmlPavedDefault
    val notModified = modifiedBy == "" || modifiedBy == AutoGeneratedUsername.generatedInUpdate

    generatedFromMML && notModified
  }

  private def pavementShouldBeRemoved(asset: PersistedLinearAsset, surfaceTypeIsNone: Seq[String]): Boolean = {
    surfaceTypeIsNone.contains(asset.linkId) && isGeneratedFromMML(asset)
  }

  private def removePavement(assetsToBeRemoved: Seq[PersistedLinearAsset], assetsToPersist: Seq[PersistedLinearAsset], operation: OperationStep, changes: Seq[RoadLinkChange], allAssetsBefore: Seq[PersistedLinearAsset]): Option[OperationStep] = {
    val changeSets = operation.changeInfo
    val expiredPavementSteps = assetsToBeRemoved.map(asset => {
      if (asset.id != 0) {
        Some(operation.copy(assetsAfter = Seq(), changeInfo = Some(changeSets.get.copy(expiredAssetIds = changeSets.get.expiredAssetIds ++ Set(asset.id)))))
      } else {
        val originalAsset = operation.assetsBefore.find(_.id == asset.oldId)
          .getOrElse(throw new NoSuchElementException(s"Could not find original asset for reporting," +
            s" asset.id: ${asset.id}, asset.oldId: ${asset.oldId}, asset.linkId: ${asset.linkId}"))
        Some(reportAssetChanges(Some(originalAsset), None, changes, operation.copy(assetsAfter = Seq()), Some(ChangeTypeReport.Deletion)))
      }
    })

    val initalOperation = Seq(Some(OperationStep(assetsAfter = assetsToPersist, changeInfo = changeSets, assetsBefore = Seq())))
    val combinedSteps = LogUtils.time(logger, "Merge operation steps after remove pavement") {
      mergeOperationSteps(expiredPavementSteps ++ initalOperation, allAssetsBefore)
    }
    combinedSteps
  }

  /**
   * Collects pavement assets that need to be removed either due to link's surface type change or due to being replaced by a known pavement class
   * Unknown assets are replaced only when a known assets is present. If all assets are unknown, do nothing.
   * @param operationStep
   * @param changes
   * @return (removableAssets, retainingAssets)
   */
  private def collectRemovablePavementAssets(operationStep: OperationStep, changes: Seq[RoadLinkChange]) = {
    val assetsByLinks = operationStep.assetsAfter.groupBy(_.linkId)
    val changesRemovePavement = changes.flatMap(_.newLinks).filter(_.surfaceType == SurfaceType.None).map(_.linkId)

    assetsByLinks.foldLeft((Seq[PersistedLinearAsset](), Seq[PersistedLinearAsset]())) {
      case ((removableAcc, retainableAcc), (_, assets)) =>
        val (removableAssets, retainableAssets) = assets.partition(a => pavementShouldBeRemoved(a, changesRemovePavement))
        val (replaceableAssets, irreplaceableAssets) = retainableAssets.partition(asset => PavementClass.isReplaceablePavementClass(asset.value))

        if (irreplaceableAssets.nonEmpty) {
          (removableAcc ++ removableAssets ++ replaceableAssets, retainableAcc ++ irreplaceableAssets)
        } else {
          (removableAcc ++ removableAssets, retainableAcc ++ retainableAssets)
        }
    }
  }


  override protected def persistProjectedLinearAssets(newLinearAssets: Seq[PersistedLinearAsset], onlyNeededNewRoadLinks: Seq[RoadLink]): Unit = {
    if (newLinearAssets.nonEmpty)
      logger.info(s"Saving projected linear assets, count: ${newLinearAssets.size}")

    logger.info(s"insert assets count: ${newLinearAssets.size}")
    newLinearAssets.foreach { linearAsset =>
      val roadlink = onlyNeededNewRoadLinks.find(_.linkId == linearAsset.linkId)
      val id =
        (linearAsset.createdBy, linearAsset.createdDateTime) match {
          case (Some(createdBy), Some(createdDateTime)) =>
            dao.createLinearAsset(linearAsset.typeId, linearAsset.linkId, linearAsset.expired, linearAsset.sideCode,
              Measures(linearAsset.startMeasure, linearAsset.endMeasure).roundMeasures(), AutoGeneratedUsername.mmlPavedDefault, linearAsset.timeStamp,
              service.getLinkSource(roadlink), fromUpdate = true, Some(createdBy), Some(createdDateTime), linearAsset.modifiedBy, linearAsset.modifiedDateTime, linearAsset.verifiedBy, linearAsset.verifiedDate, geometry = service.getGeometry(roadlink))
          case _ =>
            dao.createLinearAsset(linearAsset.typeId, linearAsset.linkId, linearAsset.expired, linearAsset.sideCode,
              Measures(linearAsset.startMeasure, linearAsset.endMeasure).roundMeasures(), AutoGeneratedUsername.mmlPavedDefault, linearAsset.timeStamp,
              service.getLinkSource(roadlink), geometry = service.getGeometry(roadlink))
        }

      linearAsset.value match {
        case Some(DynamicValue(dynamicAssetValue)) =>
          dynamicLinearAssetDao.updateAssetProperties(id, dynamicAssetValue.properties, PavedRoad.typeId)
        case _ => None
      }
    }
    if (newLinearAssets.nonEmpty)
      logger.debug(s"Added assets for linkids ${newLinearAssets.map(_.linkId)}")
  }
}
