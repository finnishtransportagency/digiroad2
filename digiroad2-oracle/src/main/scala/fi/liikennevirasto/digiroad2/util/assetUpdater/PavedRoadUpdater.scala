package fi.liikennevirasto.digiroad2.util.assetUpdater

import fi.liikennevirasto.digiroad2.GeometryUtils
import fi.liikennevirasto.digiroad2.asset.{AutoGeneratedUsername, DynamicProperty, DynamicPropertyValue, LinkGeomSource, MmlNls, PavedRoad, SideCode, UnknownLinkType}
import fi.liikennevirasto.digiroad2.client.{RoadLinkChange, RoadLinkChangeType}
import fi.liikennevirasto.digiroad2.client.vvh.ChangeInfo
import fi.liikennevirasto.digiroad2.linearasset.LinearAssetFiller._
import fi.liikennevirasto.digiroad2.linearasset.{DynamicAssetValue, DynamicValue, NumericValue, PersistedLinearAsset, RoadLink}
import fi.liikennevirasto.digiroad2.service.linearasset.LinearAssetTypes
import fi.liikennevirasto.digiroad2.service.pointasset.PavedRoadService
import fi.liikennevirasto.digiroad2.util.LinearAssetUtils
import org.joda.time.DateTime

class PavedRoadUpdater(service: PavedRoadService) extends DynamicLinearAssetUpdater(service) {
  
  override def operationForNewLink(change: RoadLinkChange, assetsAll: Seq[PersistedLinearAsset], changeSets: ChangeSet): Seq[(PersistedLinearAsset, ChangeSet)] = {
    // TODO here logic to generate paved road
    // hint getPavedRoadAssetChanges, remove this method 

    val roadLink = roadLinkService.getRoadLinksAndComplementariesByLinkIds(Set(change.newLinks.head.linkId), newTransaction = false).head
    
    if(roadLink.isPaved) {

      val defaultMultiTypePropSeq = DynamicAssetValue(Seq(DynamicProperty("paallysteluokka", "single_choice", required = false, Seq(DynamicPropertyValue("99")))))
      val defaultPropertyData = DynamicValue(defaultMultiTypePropSeq)
      
      val newAsset = PersistedLinearAsset(0, change.newLinks.head.linkId, 
        sideCode = SideCode.BothDirections.value,
        value = Some(defaultPropertyData),
        startMeasure = 0, endMeasure = GeometryUtils.geometryLength(change.newLinks.head.geometry), createdBy = None,
        createdDateTime = Some(DateTime.now()),
        modifiedBy = None, modifiedDateTime = None, expired = false, 
        typeId = LinearAssetTypes.PavedRoadAssetTypeId,
        timeStamp = LinearAssetUtils.createTimeStamp(), geomModifiedDate = Some(DateTime.now())
        /** validate this* */
        , linkSource = LinkGeomSource.NormalLinkInterface, 
        verifiedBy =None, verifiedDate = None,
        informationSource = Some(MmlNls))
      Seq((newAsset, changeSets))
    }else {
      Seq.empty[(PersistedLinearAsset, ChangeSet)]
    }
    
  }

  override def updateByRoadLinks(typeId: Int, changes: Seq[RoadLinkChange]): Unit = {
    val links = roadLinkService.getRoadLinksAndComplementariesByLinkIds(changes.filterNot(_.changeType != RoadLinkChangeType.Add).map(_.oldLink.get.linkId).toSet)
    val filteredLinks = links.filter(rl => rl.linkType.value == UnknownLinkType.value || rl.isCarTrafficRoad)
    val (add, other) = changes.partition(_.changeType == RoadLinkChangeType.Add)
    val filterchanges = other.filter(p => filteredLinks.contains(p.oldLink.get.linkId))
    super.updateByRoadLinks(typeId, filterchanges ++ add)
    // TODO check this filtering, check also new links
  }

}
