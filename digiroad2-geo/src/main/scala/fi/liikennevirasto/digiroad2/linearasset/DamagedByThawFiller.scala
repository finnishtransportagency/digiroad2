package fi.liikennevirasto.digiroad2.linearasset

import fi.liikennevirasto.digiroad2.asset._
import fi.liikennevirasto.digiroad2.linearasset.LinearAssetFiller.{ChangeSet, ValueAdjustment}
import org.joda.time.DateTime
import org.joda.time.format.DateTimeFormat

class DamagedByThawFiller extends AssetFiller {
  val ActivePeriod = "spring_thaw_period"
  val Repetition = "annual_repetition"
  val dateFormat = "dd.MM.yyyy"
  val formatter = DateTimeFormat.forPattern(dateFormat)
  val today: DateTime = DateTime.now()

  override def updateValues(roadLink: RoadLinkForFillTopology, assets: Seq[PieceWiseLinearAsset], changeSet: ChangeSet): (Seq[PieceWiseLinearAsset], ChangeSet) = {

    def getProperties(publicId: String, propertyData: Seq[DynamicProperty]): Seq[DynamicPropertyValue] = {
      propertyData.find(p => p.publicId == publicId) match {
        case Some(props) => props.values
        case _ => Seq()
      }
    }

    def toCurrentYear(period: DatePeriodValue): DatePeriodValue = {
      val endDate = DateParser.stringToDate(period.endDate, DateParser.DatePropertyFormat)
      val startDate = DateParser.stringToDate(period.startDate, DateParser.DatePropertyFormat)
      val difference = today.getYear - endDate.getYear
      if(difference == 0)
        DatePeriodValue(DateParser.dateToString(startDate.plusYears(1), DateParser.DatePropertyFormat), DateParser.dateToString(endDate.plusYears(1), DateParser.DatePropertyFormat))
      else
        DatePeriodValue(DateParser.dateToString(startDate.plusYears(difference), DateParser.DatePropertyFormat), DateParser.dateToString(endDate.plusYears(difference), DateParser.DatePropertyFormat))
    }

    def outsidePeriod(value: DynamicPropertyValue): Boolean = {
      val period = DatePeriodValue.fromMap(value.value.asInstanceOf[Map[String, String]])
      val endDate = DateParser.stringToDate(period.endDate, DateParser.DatePropertyFormat)
      val thisYear = today.getYear
      val endDateYear = endDate.getYear

      thisYear - endDateYear >= 0 && endDate.isBefore(today)
    }

    def isRepeated(checkbox: Seq[DynamicPropertyValue]): Boolean = {
      checkbox.exists(x => x.value.asInstanceOf[String].equals("1"))
    }

    def needUpdates(properties: Seq[DynamicProperty]): Boolean = {
      isRepeated(getProperties(Repetition, properties)) &&
        getProperties(ActivePeriod, properties).exists { period =>
          outsidePeriod(period)
        }
    }

    val (toUpdate, noneNeeded) = assets.partition( asset =>
      asset.value.map(_.asInstanceOf[DynamicValue].value.properties).exists {
        propertyData => needUpdates(propertyData)
      }
    )

    val adjustedAssets = toUpdate.map { asset =>
      asset.copy(value = Some(DynamicValue(DynamicAssetValue(asset.value.get.asInstanceOf[DynamicValue].value.properties.map { prop =>
          if (prop.publicId == ActivePeriod) {
            prop.copy(values = prop.values.map { period =>
              if(outsidePeriod(period))
                DynamicPropertyValue(DatePeriodValue.toMap(toCurrentYear(DatePeriodValue.fromMap(period.value.asInstanceOf[Map[String, String]]))))
              else
                period
            })
          } else prop
      }))), modifiedBy = Some(AutoGeneratedUsername.annualUpdate))
    }

    (adjustedAssets ++ noneNeeded, changeSet.copy(valueAdjustments = changeSet.valueAdjustments ++ adjustedAssets.map {asset => ValueAdjustment(asset)}))
  }
}
